#include "../include/magic.h"
#include "../include/myfunction.h"
#include "../include/mytime.h"
#include <iostream>
#include <sstream>
#include <map>
#include <set>
#include <queue>
#include <cassert>
#include <fstream>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <cstdlib>
#include <ctime>
#include <random>
#include <unordered_set>
#include <iomanip>
#include <filesystem>

std::string base_path = "/home/panjiaxiang/pjx_research/magic/";

//构造普通门
Gate::Gate(line_idx output, std::vector<line_idx> &&inputs) : m_inputs(inputs), m_output(output){}

void Magic::RL_API()//与run_SA()不可以同时使用，因为都调用了mapping_for_SA函数，重复调用会多次修改变同一变量
{   
	//cost
	assert( m_roots.size() != 0);
	std::vector<gate_idx> initial_gates = RootsToGates(m_roots);
	int cost_result = cost_function_RL( initial_gates );

	//mapping
	cellsinfoSA = new CellsInfo( cost_result + PI_size_without_zero_one );
	initialize_cells_for_SA( cost_result );
	mapping_for_SA( m_roots );

	std::cout << "*********RL API*********" << std::endl;
	std::cout << "Reuse Cycles: " << m_reuse_cycles_SA << std::endl;
	std::cout << "COST: " << PI_size_without_zero_one + cost_result << std::endl;
	std::cout << "CYCLES: " << m_time_SA << std::endl;
}

void Magic::show_simplest_mapping_info( const std::pair<int, std::vector<gate_idx>> &cost_roots_pair, bool old_version)
{
	if( old_version )
	{
		m_print("cost for functional cells:", costRootsPair.first );
		m_print("cost by SA algo:" ,costRootsPair.first + PI_size_without_zero_one);
		assert( (m_time_SA != 0) && (m_reuse_cycles_SA != 0) );
		m_print("Cycles by SA algo:" , m_time_SA );
		m_print("ReuseCycles:" , m_reuse_cycles_SA );

		//The correctness of the cost is verified according to the order of the root generated by the SA algorithm
		//Make sure that the method of selecting candidate nodes in mapping_for_SA() and RootsToGates() is the same
		std::vector<gate_idx> gates = RootsToGates(costRootsPair.second);
		assert(gates.size() == m_gates.size());
		assert(mapping_gates_SA.size() == m_gates.size());
		int cost = cost_function(gates).first;
		m_Print("cost by final Roots: ", cost + PI_size_without_zero_one);
		assert(( costRootsPair.first + PI_size_without_zero_one ) == ( cost + PI_size_without_zero_one ));//ensure SA result equals to ROOTs(SA) result
	}
	else
	{
		std::cout << "*******************************************************************************\n"
					<< "*                            Mapping statistics                               *\n"
					<< "*******************************************************************************\n";
		std::cout << "-------------------------------------------------------------------------------\n"
		<< std::setw( 3 ) << std::left << " "
		<< "| RRAMs | = " << costRootsPair.first + PI_size_without_zero_one << std::setw( 4 ) << " "
		<< "| Cycles | = " << m_time_SA << std::setw( 4 ) << " "
		<< "| Reuse Cycles | = " << m_reuse_cycles_SA << "\n";
		std::cout << "-------------------------------------------------------------------------------\n";
	}
}

void Magic::run_simplest()
{
	costRootsPair = SimulatedAnnealing( true );
	cellsinfoSA = new CellsInfo(costRootsPair.first + PI_size_without_zero_one);
	initialize_cells_for_SA( costRootsPair.first );
	mapping_for_SA( costRootsPair.second );
	show_simplest_mapping_info( costRootsPair, true );
	save_generated_micro_operation_SA_veriSIMPLER( base_path + "result_SA" );
	save_generated_micro_operation_SA( base_path + "result_SA" );  //FILE PATH CAN BE MODIFIED
	// write_dot( "IS", base_path + "dot", true, false ); //FILE PATH CAN BE MODIFIED
	// if(PI_size_without_zero_one + costRootsPair.first <= 10)
	// {
	// 	eda_competition_show( m_micro_operation_SA, PI_size_without_zero_one + costRootsPair.first,  base_path + "mapped_layout.dot", [](const Gate& gate) { return gate.get_map_SA(); }, true);  //FILE PATH CAN BE MODIFIED
	// }
}

void Magic::run_simpler()
{
	initialize_cells();
	if(perform_allocate_row())//modifiable( sorted_gates )
	{
		std::cout << " SUCCESSFUL! " << std::endl;
		assert(mapping_gates.size() == m_gates.size());//ensure mapping all gates, to get the true value of cost_function()；
		generate_stats( false );
		// The minimum number of RRAMs required to complete SIMPLER mapping is equal to the number of RRAMs calculated by cost_function (), 
		// and this conclusion is sufficient to verify the accuracy of cost_function();
		// m_print("gates size: " ,mapping_gates.size(),"cost: " , cost_function(mapping_gates).first + PI_size_without_zero_one, "final RRAMS: " ,cost_function(mapping_gates).second);
		// generate_micro_operation();
		save_generated_micro_operation( base_path + "result" ); //default: home dir //FILE PATH CAN BE MODIFIED
		if(m_row_size <= 10)
		{
			eda_competition_show( m_micro_operation, m_row_size, base_path + "mapped_layout.dot", [](const Gate& gate) { return gate.get_map(); }, true );  //FILE PATH CAN BE MODIFIED
		}
	}else
	{
		std::cout << " FAILED " << std::endl;
	}
	write_dot( "IS", base_path + "dot", true, false ); //FILE PATH CAN BE MODIFIED
	//RL_API()与run_SA()不可以同时使用，因为都调用了mapping_for_SA函数，重复调用会多次修改变同一变量
	// //RL_API中，通过修改CU或者IS来决定选取何种节点收集策略，RL_API中就会输出对应策略得到的结果
	// RL_API();
}

void Magic::design_space_exploration()
{
	initialize_cells();
	if(perform_allocate_row())
	{
		std::cout << " SUCCESSFUL! " << std::endl;
		assert(mapping_gates.size() == m_gates.size());
		//generate_stats( true );
	}else
	{
		std::cout << " FAILED " << std::endl;
	}
	RL_API();
}

void Magic::prepare( bool show_stats_type )
{
	auto Par = 0;
	ElapsedTimer t( true );
	match_logic_depth();
	compute_gate_outdegree();
	compute_gate_indegree();
	match_cell_usage();
	compute_intermediate_storage( false );//modifiable( collect_gates )
	count_real_PI_num();//count real PI
	compute_roots();//initial m_roots
	// set_root_tree_size();
	getFanoutLevelforGates();
	getFanoutNodeNumforGates();// Collecting information about fan-in and fan-out nodes
	Par = t.get_elapsed_us();
	std::cout << "  +Time for prepare graph: " << 1.0 * Par / 1000 << "  ms\n";
	std::cout << "*******************************************************************************\n";
	std::cout << "\n";
	show_stats( show_stats_type );
}

void Magic::tt()//Test the correctness of the cost function of the semi-adder (correct)
{
	std::vector<std::vector<int>> gates_vecs = {{0}, {0, 1}, {0, 1, 2}, {0, 1, 2, 3}, {0, 1, 2, 3, 4}};
	for(const auto & gates_vec : gates_vecs)
	{
		for(const auto & gate : gates_vec)
		{
			std::cout << m_gates[gate].get_name() << ", ";
		}
		std::cout << std::endl;
		std::cout << "max: " << cost_function(gates_vec).first << " final: " << cost_function(gates_vec).second << std::endl;
	}
}

void Magic::test_topo_sort()//test cost_function for topo_sort
{
	std::vector<gate_idx> topo = topo_sort();
	for(const auto & t : topo){
		std::cout << m_gates[t].get_name() << ",";
	}
	std::cout << std::endl;
	std::pair<int, int> result = cost_function(topo);
	std::cout << "max_intermediate_storage: " << result.first << std::endl;
	std::cout << "RRAM occupied after processing " << m_gates[topo.back()].get_name() 
	<< " : " << result.second << std::endl;
}

void Magic::test_enum_exec_seq()//test cost_function for all_topo_sort
{
	std::vector<std::vector<gate_idx>> enum_topo = enum_topo_sort();

	for(const auto & enums : enum_topo)
	{
		for(const auto &enu : enums)
		{
			std::cout << m_gates[enu].get_name() << ",";
		}
		std::cout << std::endl;
		std::pair<int, int> result = cost_function(enums);
		std::cout << "intermediate_storage: " << result.first << std::endl;
		std::cout << "RRAM occupied after processing " << m_gates[enums.back()].get_name() 
	<< " : " << result.second << std::endl;
	}
}

void Magic::test_GreedyExecutionSequence( const std::string &file_path )//贪心选择执行顺序 并输出到文本
{
	std::vector<gate_idx> results = GreedyExecutionSequence();
	assert( results.size() == m_gates.size() );
	std::ofstream ofs(file_path, std::ios::app);
	ofs << m_benchmark_name << " results size: " << results.size() << " gates size: " << m_gates.size() <<std::endl;
	for(const auto& result : results)
	{
		ofs << result << ";";
	}
	ofs << std::endl;
	ofs.close();
}

void Magic::test_result_of_greedy(const int &index, const std::string &file_path)//解析生成的顺序文本，并做映射
{
	std::ifstream ifs( file_path );
	std::vector<gate_idx> gate_vec = parse_from_result(ifs, index);
	assert(gate_vec.size() == m_gates.size());
	if(VecGateAPI(gate_vec))
	{
		std::cout << " SUCCESSFUL! " << std::endl;
		assert(mapping_gates.size() == m_gates.size());//ensure mapping all gates, to get the true value of cost_function()；
		generate_stats( false );
		save_generated_micro_operation( "../result_greedy" );
	}
	else
		std::cout << " FAILED " << std::endl;
}

void Magic::show_stats( bool for_RL )
{
	if( for_RL )
	{
		std::cout << "********** stastics ********** " << std::endl;
		std::cout << "total gates size: " << get_gates().size() << std::endl;
		std::cout << "nor2 size: " << get_nor2s().size() << std::endl;
		std::cout << "nor3 size: " << get_nor3s().size() << std::endl;
		std::cout << "nor4 size: " << get_nor4s().size() << std::endl;
		std::cout << "nor5 size: " << get_nor5s().size() << std::endl;
		std::cout << "inv1 size: " << get_inv1s().size() << std::endl;
		std::cout << "buf size: " << get_bufs().size() << std::endl;
		std::cout << "zero size: " << get_zeros().size() << std::endl;
		std::cout << "one size: " << get_ones().size() << std::endl;
		std::cout << "lines size: " << get_lines().size() << std::endl;
		std::cout << "wire size: " << get_wires().size() << std::endl;
		std::cout << "inputs size: " << PI_size_without_zero_one << std::endl;
		std::cout << "outputs size: " << get_outputs().size() << std::endl;
		std::cout << "max logic depth: " << get_mld() + 1 << std::endl;
		std::cout << "max fan-out node count: " << get_fo_node_num_max() <<  std::endl;
		std::cout << "average fan-out node count: " << get_fo_node_num_ave() << std::endl;
		// std::cout << "max fan-in node count: " << std::endl; //no meaning
		std::cout << "average fan-in node count: " << get_fanin_node_num_ave() << std::endl;
		// std::cout << "max node fan-out level: " << std::endl; //no meaning
		std::cout << "average node fan-out level: " << get_fo_lev_ave() << std::endl;
	}
	else
	{
		advance_show_stats();
	}
	
}

void Magic::advance_show_stats()
{
	std::cout << "*******************************************************************************\n"
				<< "*                            Statistic information                            *\n"
				<< "*******************************************************************************\n";
	std::cout << "-------------------------------------------------------------------------------\n"
		<< "  +Circuit_statistic : "
		<< "\n"
		<< std::setw( 3 ) << std::left << " "
		<< "| Input | = " << PI_size_without_zero_one << std::setw( 4 ) << " "
		<< "| Output | = " << get_outputs().size() << std::setw( 4 ) << " "
		<< "| Level | = " << get_mld() + 1 << "\n";
	std::cout << "-------------------------------------------------------------------------------\n"
		<< "  +Level_statistic : "
		<< "\n"
		<< std::setw( 3 ) << std::left << " "
		<< "| Max Fanout | = " << get_fo_node_num_max() << std::setw( 4 ) << " "
		<< "| Average Fanout | = " << get_fo_node_num_ave() << std::setw( 4 ) << " "
		<< "| Average Fanin | = " << get_fanin_node_num_ave() << "\n"
		<< "-------------------------------------------------------------------------------\n";
	std::cout << "  +Gates_statistic : " << "\n";
	std::cout << std::setw( 3 ) << " " << std::setfill( '-' ) << std::setw( 68 ) << "" << std::setfill( ' ' ) << std::endl;
		std::cout << std::setw( 3 ) << " "
		<< "| " << std::left << std::setw( 4 ) << "Name"
		<< " |" << std::setw( 4 ) << "nor2"
		<< " |" << std::setw( 4 ) << "nor3"
		<< " |" << std::setw( 4 ) << "nor4"
		<< " |" << std::setw( 4 ) << "nor5"
		<< " |" << std::setw( 4 ) << "inv1"
		<< " |" << std::setw( 4 ) << "buf"
		<< " |" << std::setw( 4 ) << "zero"
		<< " |" << std::setw( 4 ) << "one"
		<< " |" << std::setw( 7 ) << "total gates"
		<< " |" << std::endl;
		std::cout << std::setw( 3 ) << " " << std::setfill( '-' ) << std::setw( 68 ) << "" << std::setfill( ' ' ) << std::endl;
		std::cout << std::setw( 3 ) << " "
		<< "| " << std::left << std::setw( 4 ) << "nums"
		<< " |" << std::setw( 4 ) << ( get_nor2s().size() == 0 ? " / " : std::to_string( get_nor2s().size() ) ) 
		<< " |" << std::setw( 4 ) << ( get_nor3s().size() == 0 ? " / " : std::to_string( get_nor3s().size() ) ) 
		<< " |" << std::setw( 4 ) << ( get_nor4s().size() == 0 ? " / " : std::to_string( get_nor4s().size() ) ) 
		<< " |" << std::setw( 4 ) << ( get_nor5s().size() == 0 ? " / " : std::to_string( get_nor5s().size() ) ) 
		<< " |" << std::setw( 4 ) << ( get_inv1s().size() == 0 ? " / " : std::to_string( get_inv1s().size() ) ) 
		<< " |" << std::setw( 4 ) << ( get_bufs().size() == 0 ? " / " : std::to_string( get_bufs().size() ) ) 
		<< " |" << std::setw( 4 ) << ( get_zeros().size() == 0 ? " / " : std::to_string( get_zeros().size() ) ) 
		<< " |" << std::setw( 4 ) << ( get_ones().size() == 0 ? " / " : std::to_string( get_ones().size() ) ) 
		<< " |" << std::setw( 7 ) << ( get_gates().size() == 0 ? " / " : std::to_string( get_gates().size() ) ) << "     |" << std::endl;

		std::cout << std::setw( 3 ) << " " << std::setfill( '-' ) << std::setw( 68 ) << "" << std::setfill( ' ' ) << std::endl;
		std::cout << "-------------------------------------------------------------------------------\n";
		std::cout << std::endl;
}

void Magic::eda_competition_show( const std::map<int, std::variant<gate_idx, std::vector<gate_idx>>> &m_micro_operation, const int &row_size, const std::string &file_path, std::function<int(const Gate&)> get_map_idx_strategy, bool generate_png )
{
	assert( row_size <= 10 );//for small case

	std::vector<std::string> operations_matrix( row_size );

	std::ofstream ofs( file_path, std::ios::out );

	ofs << "digraph G {\n";
	ofs << "    node [shape=plaintext];\n";
	ofs << "    graph [splines=false];\n";
	ofs << std::endl;
	ofs << "    table [label=<\n";
	ofs << "    <table border=\"1\" cellborder=\"1\" cellspacing=\"0\">\n";
	//first line
	ofs << "<tr>\n";
	ofs << "    <td fixedsize=\"true\" width=\"50\" height=\"30\"></td>\n";
	int cloumn = 0;
	for (int i = 0; i < row_size; ++i) 
	{
		std::string customChar = "C" + std::to_string( cloumn );
		ofs << "    <td fixedsize=\"true\" width=\"50\" height=\"30\"><font point-size=\"10\">" << customChar << "</font></td>\n";
		cloumn++;
	}
	ofs << "</tr>\n";

	for(int i = 0; i < m_inputs.size(); i++)
	{
		std::string input_name = m_lines[get_inputs()[i]].name;
		if( m_lines[get_inputs()[i]].name == "one" || m_lines[get_inputs()[i]].name == "zero" )
			continue;
		operations_matrix[i] = input_name;
	}
	for( int i = m_inputs.size(); i < row_size; ++i )
	{
		operations_matrix[i] = std::to_string( 1 );
	}
	std::cout << std::setw(6) << "T0";
	std::for_each( operations_matrix.begin(), operations_matrix.end(), [](const std::string &str){ std::cout << std::setw(6) << str; } );
	std::cout << std::endl;
	generate_html_table( operations_matrix, 0, ofs);//second line( assign PI and init other cells )
	
	int T = 1;
	for( const auto& [time, value] : m_micro_operation )
	{   
		std::string cycle_name = "T" + std::to_string( T );
		if( std::holds_alternative<gate_idx>(value) )//Map
		{
			gate_idx gate_id = std::get<gate_idx>(value);
			std::string gate_name = m_gates[gate_id].get_name();
			// int cell_idx = m_gates[gate_id].get_map();//
			int cell_idx = get_map_idx_strategy( m_gates[gate_id] );
			operations_matrix[cell_idx] = gate_name;
			// identify output gate, different color when show
			int index = -1;
			if( m_lines[ m_gates[gate_id].get_output() ].is_output )
				index = cell_idx;
			//
			std::cout << std::setw(6) << cycle_name;
			std::for_each( operations_matrix.begin(), operations_matrix.end(), [](const std::string &str){ std::cout << std::setw(6) << str; } );
			std::cout << std::endl;
			generate_html_table(operations_matrix, T, ofs, index);
			T++;
		}
		else if( std::holds_alternative<std::vector<gate_idx>>(value))//Init
		{
			std::vector<gate_idx> gate_id_vec = std::get<std::vector<gate_idx>>( value );

			// std::vector<std::string> gate_name_vec( gate_id_vec.size() );
			// std::vector<int> cell_idx_vec( gate_id_vec.size() );
			// std::transform( gate_id_vec.begin(), gate_id_vec.end(), gate_name_vec.begin(), [this](int x){ return m_gates[x].get_name(); } );
			// std::transform( gate_id_vec.begin(), gate_id_vec.end(), gate_name_vec.begin(), [this](int x){ return m_gates[x].get_map(); }  );

			for(const auto &gate_id : gate_id_vec)
			{
				// operations_matrix[ m_gates[gate_id].get_map() ] = std::to_string( 1 );
				operations_matrix[ get_map_idx_strategy( m_gates[gate_id] ) ] = std::to_string( 1 );
			}
			std::cout << std::setw(6) << cycle_name;
			std::for_each( operations_matrix.begin(), operations_matrix.end(), [](const std::string &str){ std::cout << std::setw(6) << str; } );
			std::cout << std::endl;
			generate_html_table(operations_matrix, T, ofs);
			T++;
		}
		else
		{
			std::cerr << "Error\n";
		}
	}

	ofs << "    </table>\n";
	ofs << "    >];\n";
	ofs << "}\n";
	ofs.close();

	if(generate_png)
	{
		// ../dot/simpler_fa_IS.dot
		// /dot/simpler_fa_IS
		// ../dot/simpler_fa_IS.png
		std::string png_file = m_split(file_path, ".")[0] + ".png"; 

		std::string command = "dot -Tpng " + file_path + " -o " + png_file;
		// m_print( command );
		int result = system( command.c_str() );
		if( result != 0 ) std::cerr << "[Error] Command: " << command << "Failed\n";

		// std::string show_command = "eog " + png_file + " 2>/dev/null";
		// int result_1 = system( show_command.c_str() );
		// if( result_1 != 0 ) std::cerr << "[Error] Command: " << show_command << "Failed\n";
	}
}

void Magic::generate_html_table( const std::vector<std::string> &operations_matrix, const int &Time, std::ofstream &ofs, int index )
{

	ofs << "<tr>\n";
	std::string time_string = "T" + std::to_string( Time );
	ofs << "    <td bgcolor=\"salmon\" fixedsize=\"true\" width=\"50\" height=\"30\"><font point-size=\"10\">" << time_string << "</font></td>\n";

	for (int i = 0; i < operations_matrix.size(); ++i) 
	{
		std::string customChar = operations_matrix[i]; 
		if( i == index )
		{
			ofs << "    <td bgcolor=\"cyan\" fixedsize=\"true\" width=\"50\" height=\"30\"><font point-size=\"10\">" << customChar << "</font></td>\n";
			continue;
		}
		if( i <= m_inputs.size() - 1 )
		{
			ofs << "    <td bgcolor=\"gray\" fixedsize=\"true\" width=\"50\" height=\"30\"><font point-size=\"10\">" << customChar << "</font></td>\n";
		}
		else
		{
			ofs << "    <td fixedsize=\"true\" width=\"50\" height=\"30\"><font point-size=\"10\">" << customChar << "</font></td>\n";
		} 
	}

	ofs << "</tr>\n";
}

line_idx Magic::add_input(const std::string& name)
{
	line_idx p_line = ensure_line(name);
	if (!m_lines[p_line].is_input) 
	{
		m_lines[p_line].is_input = true;
		m_inputs.push_back(p_line);
	}
	return p_line;
}

line_idx Magic::add_output(const std::string& name)
{
	line_idx p_line = ensure_line(name);
	if (!m_lines[p_line].is_output) 
	{
		m_lines[p_line].is_output = true;
		m_outputs.push_back(p_line);
	}
	return p_line;
}

line_idx Magic::add_wire(const std::string& name)
{

	line_idx p_line = ensure_line(name);
	if(!m_lines[p_line].is_wire)
	{
		m_lines[p_line].is_wire = true;
		m_wires.push_back(p_line);
	}
	return p_line;
}

gate_idx Magic::add_gate(const std::string& gate_name, const std::vector<std::string> &input_names, const std::string &output_name, bool is_inv1, bool is_nor2, bool is_buf, bool is_zero, bool is_one, int is_multi_nor)
{
	std::vector<line_idx> inputs;
	for (size_t i = 0; i < input_names.size(); ++i) 
	{
		inputs.push_back(m_name_to_line_idx.find(input_names[i])->second);
	}

	line_idx p_output = m_name_to_line_idx.find(output_name)->second;
	m_gates.emplace_back(p_output, std::move(inputs));
	m_gates.back().inv1() = is_inv1;
	if(is_multi_nor == -1)
	{
		m_gates.back().nor2() = is_nor2;
		m_gates.back().buf() = is_buf;
		m_gates.back().zero() = is_zero;
		m_gates.back().one() = is_one;
	}
	else if(is_multi_nor == 3)
	{
		m_gates.back().nor3() = true;
	}
	else if(is_multi_nor == 4)
	{
		m_gates.back().nor4() = true;
	}
	else if(is_multi_nor == 5)
	{
		m_gates.back().nor5() = true;
	}

	gate_idx gate = m_gates.size() - 1;
	m_gates.back().id() = gate;
	m_gates.back().name() = gate_name;
	if(m_gates.back().get_inv1())
	{
		m_inv1s.push_back(gate);	 
	}
	{
	if(m_gates.back().get_nor2())
		m_nor2s.push_back(gate);	 
	}
	if(m_gates.back().get_buf())
	{
		m_bufs.push_back(gate);
	}
	if(m_gates.back().get_zero())
	{
		m_zeros.push_back(gate);
	}
	if(m_gates.back().get_one())
	{
		m_ones.push_back(gate);
	}
	if(m_gates.back().get_nor3())
	{
		m_nor3s.push_back(gate);
	}
	if(m_gates.back().get_nor4())
	{
		m_nor4s.push_back(gate);
	}
	if(m_gates.back().get_nor5())
	{
		m_nor5s.push_back(gate);
	}
	m_lines[p_output].source = gate;

	for (size_t i = 0; i < m_gates[gate].get_inputs().size(); ++i) {
		m_lines[m_gates[gate].get_inputs().at(i)].connect_as_input(gate);
	}
	return gate;
}

line_idx Magic::line(const std::string &name)
{
	auto it = m_name_to_line_idx.find(name);

	if (it != m_name_to_line_idx.end())
	{
		return it->second;
	}

	return NULL_INDEX;
}

const line_idx Magic::get_line(const std::string &name) const
{
	auto it = m_name_to_line_idx.find(name);

	if (it != m_name_to_line_idx.end())
	{
		return it->second;
	}
	return NULL_INDEX;
}

void Magic:: match_logic_depth() {
  for (int i = 0, num = m_outputs.size(); i < num; i++)
  {
    int level = compute_node_depth(m_lines[m_outputs[i]].source);
    if (level > max_logic_depth) max_logic_depth = level;
  }
  m_node_level.resize(max_logic_depth + 1);//level = 2,menas 3 level(because level of pi is 0)
  for (int i = 0; i < m_gates.size(); i++) 
  {
    m_node_level[m_gates[i].get_level()].push_back(i);//level - vector<gate_idx>
  }
}

int Magic::compute_node_depth(const gate_idx g_id) 
{
  Gate& gate = m_gates[g_id];
  if (gate.get_level() != NO_LEVEL) return gate.get_level();
  int max_depth = NO_LEVEL;
  int level = -1;
  for (const auto& child : gate.get_inputs()) 
  {
    if (m_lines[child].is_input) continue;
    level = compute_node_depth(m_lines[child].source);
    if (level > max_depth) {
      max_depth = level;
    }
  }
  if (max_depth == NO_LEVEL) 
    max_depth = -1;
  m_gates[g_id].level() = max_depth + 1;
  return m_gates[g_id].level();
}

void Magic::match_cell_usage()
{
	for(const auto& outline_idx : m_outputs)
	{
		compute_cell_usage(m_lines[outline_idx].source);
	}
}

unsigned int Magic::compute_cell_usage(const gate_idx &gate_idx)
{
	if(m_gates[gate_idx].get_cell_usage() > 0)
	{
		return m_gates[gate_idx].get_cell_usage();
	}
	else if(m_gates[gate_idx].get_indegree() == 0)//PI
	{
		m_gates[gate_idx].set_cell_usage(1);
		return m_gates[gate_idx].get_cell_usage();
	}
	else
	{
		std::vector<unsigned int> v;
		for(const auto &child : m_gates[gate_idx].get_inputs())
		{
			if(!m_lines[child].is_input)
			{
				auto gate = m_lines[child].source;
				v.push_back(compute_cell_usage(gate));
			}			
		}
		std::sort(v.begin(), v.end());
		std::reverse(v.begin(), v.end());
		std::vector<unsigned int> v1(v.size());
		std::iota(v1.begin(), v1.end(), 0);//element:0 to size()-1
		std::vector<int> sums(v.size());
		for (unsigned int i = 0; i < v.size(); ++i) 
		{
        	sums[i] = v[i] + v1[i];//equal to CU(n) + (n - 1) 
			//CU(0) + 0;CU(1) + 1;
    	}
		m_gates[gate_idx].set_cell_usage(*std::max_element(sums.begin(), sums.end()));
    	return m_gates[gate_idx].get_cell_usage();
	}
}

std::vector<gate_idx> Magic::collect_gates(const gate_idx &gate_index, std::unordered_set<gate_idx> &visited)//modifiable
{
	visited.insert(gate_index);

	std::vector<std::pair<gate_idx, unsigned int>> sorted_gates;
    std::vector<gate_idx> result_gates;

    if(m_gates[gate_index].get_indegree() != 0)
    {
        for(const auto & input_line : m_gates[gate_index].get_inputs())
        {
            if(m_lines[input_line].is_input)
                continue;
            const gate_idx &child_idx = m_lines[input_line].source;
            Gate& children = m_gates[child_idx];
			//modifiable
			sorted_gates.push_back(std::make_pair(child_idx, children.get_cell_usage()));
			// sorted_gates.push_back(std::make_pair(child_idx, children.m_reference_value));
		
        }
		std::sort(sorted_gates.begin(), sorted_gates.end(),
		[this](const std::pair<gate_idx, unsigned int> &a, const std::pair<gate_idx, unsigned int> &b)
		{ 
			//modifiable
			if(a.second != b.second){
				return a.second > b.second;
			}
			else{
				// if(m_gates[a.first].max_fanout_level < m_gates[b.first].mini_fanout_level){
				if(m_gates[a.first].max_fanout_level < m_gates[b.first].max_fanout_level){
					return true;
				}
				else{
					return a.first < b.first;
				}
			}
		});
        for(const auto &p : sorted_gates)
        {
			if(visited.count(p.first))
				continue;
			std::vector<gate_idx> child_result = collect_gates(p.first, visited);
			result_gates.insert(result_gates.end(), child_result.begin(), child_result.end());
        }
    }

	result_gates.push_back(gate_index);
    return result_gates; 
}

std::vector<gate_idx> Magic::depth_first_search(const gate_idx &gate, std::vector<gate_idx> &result, std::unordered_set<gate_idx> &visited)
{
	result.push_back(gate);
	visited.emplace(gate);

	for(const auto &input : m_gates[gate].get_inputs())
	{
		if(m_lines[input].is_input)
			continue;
		gate_idx children_index = m_lines[input].source;
		if(visited.count(children_index))
			continue;
		depth_first_search(children_index, result, visited);
	}
	return result;
}

void Magic::compute_intermediate_storage( bool show_sequence_and_cost )
{
	for( auto& gate : m_gates)
	{
		// std::vector<gate_idx> result{};
		std::unordered_set<gate_idx> visited{};
		// depth_first_search(gate.get_id(), result, visited);
		// std::reverse(result.begin(), result.end());

		std::vector<gate_idx> result = collect_gates(gate.get_id(), visited);

		int intermediate_storage = cost_function(result).first;
		if( show_sequence_and_cost )
		{
			for(const auto& res : result)
			{
				std::cout << m_gates[res].get_name() << ",";
			}
			std::cout << intermediate_storage;
			std::cout << std::endl;
		}
		gate.set_intermediate_storage(intermediate_storage);
	}
}

bool Magic::perform_allocate_row()
{
	auto Par = 0;
	ElapsedTimer t(true);
	if(m_sort_roots == "NO")//do not sort the roots
	{
		for(const auto& outline_idx : m_outputs)
		{
			m_traversal_roots.push_back(m_lines[outline_idx].source);
			// if(!allocate_row_by_intermediate_storage(m_lines[outline_idx].source))
			if(!allocate_row(m_lines[outline_idx].source))//修改这个地方，来选取策略是按照CU 还是 IS
			{
				std::cout << "*******************************False - no mapping******************************\n";
				return false;
			}
		}
		Par =  t.get_elapsed_us();
		m_print("******************* Time of SIMPLER Mapping is : ", 1.0 * Par / 1000, " ms ********************");
		return true;
	}
	else//sort the roots
	{
		std::vector<std::pair<gate_idx, unsigned int>> sorted_roots;
		std::vector<std::pair<gate_idx, unsigned int>> sorted_roots_by_trees;//
		std::vector<std::pair<gate_idx, unsigned int>> new_sort;//Sort from smallest to largest, then select elements from the middle to the sides
		for(const auto& outline_idx : m_outputs)
		{	
			const gate_idx &gate_index = m_lines[outline_idx].source;
			Gate& children = m_gates[gate_index];
			sorted_roots.push_back(std::make_pair(gate_index, children.get_cell_usage()));
			sorted_roots_by_trees.push_back(std::make_pair(gate_index, children.get_tree_size()));//
		}
		if(m_sort_roots == "DESCEND")
		{
			std::sort(sorted_roots.begin(), sorted_roots.end(), 
			[](const std::pair<gate_idx, unsigned int> &a, const std::pair<gate_idx, unsigned int> &b)
			{ return a.second > b.second; });//DESCEND
		}
		else if(m_sort_roots == "ASCEND")
		{
			std::sort(sorted_roots.begin(), sorted_roots.end(), 
			[](const std::pair<gate_idx, unsigned int> &a, const std::pair<gate_idx, unsigned int> &b)
			{ return a.second < b.second; });//ASCEND
		}
		else if(m_sort_roots == "RANDOM")
		{
			std::random_device rd;
			std::mt19937 g(rd());
			std::shuffle(sorted_roots.begin(), sorted_roots.end(), g);
		}
		else if(m_sort_roots == "Tree_Size")//sort roots by tree size
		{
			std::sort(sorted_roots_by_trees.begin(), sorted_roots_by_trees.end(),
			[](std::pair<gate_idx, unsigned int>a, std::pair<gate_idx, unsigned int> &b)
			{return a.second > b.second; });

			int roots_size = sorted_roots_by_trees.size();
			int middle_index = (roots_size - 1)/2;
			new_sort.push_back(sorted_roots_by_trees[middle_index]);
			// while ( ((middle_index >= 0) && (middle_index <= middle_index))
			// || ((middle_index >= middle_index) && (middle_index <= (sorted_roots_by_trees.size() - 1))) )
			// {
			// 	new_sort.push_back(sorted_roots_by_trees[middle_index]);

			// }
			int left = middle_index - 1;
			int right = middle_index + 1;
			while(left >= 0 || right < roots_size){
				if(right < roots_size){
					new_sort.push_back(sorted_roots_by_trees[right]);
					right++;
				}
				if(left >= 0){
					new_sort.push_back(sorted_roots_by_trees[left]);
					left --;
				}
			}
			// for(const auto &[gate, size] : new_sort){
			// 	std::cout << m_gates[gate].get_name() << " , " << "size" << size << std::endl;
			// }
		}
		else
		{
			m_print("unknown sort option!");
			return false;
		}
		if(m_sort_roots != "Tree_Size"){
			for(const auto & root : sorted_roots)
			{
				m_traversal_roots.push_back(root.first);
				auto input_line = m_gates[root.first].get_inputs();
				for(const auto & input : input_line)
				{
					if(m_lines[input].is_input)
						continue;
				}
				if(!allocate_row(root.first))
				{
					std::cout << "********************False - no mapping********************\n";
					return false;
				}
			}
			Par =  t.get_elapsed_us();
			m_print("********** Time of allocate is :", 1.0 * Par / 1000, " ms **********");
			return true;
		}
		else{
			for(const auto & root : new_sort)//这个地方需要修改  sorted_roots_by_trees OR new_sort
			{
				m_traversal_roots.push_back(root.first);
				auto input_line = m_gates[root.first].get_inputs();
				for(const auto & input : input_line)
				{
					if(m_lines[input].is_input)
						continue;
				}
				if(!allocate_row(root.first))
				{
					std::cout << "********************False - no mapping********************\n";
					return false;
				}
			}
			Par =  t.get_elapsed_us();
			m_print("********** Time of allocate is :", 1.0 * Par / 1000, " ms **********");
			return true;
		}
	} 
}

bool Magic::allocate_row(const gate_idx &gate_index)
{
	std::vector<std::pair<gate_idx, unsigned int>> sorted_gates;//gate_idx CU
	if(m_gates[gate_index].get_indegree() != 0)
	{
		for(const auto & input_line : m_gates[gate_index].get_inputs())
		{
			if(m_lines[input_line].is_input)
				continue;
			const gate_idx &child_idx = m_lines[input_line].source;
			Gate& children = m_gates[child_idx];
			sorted_gates.push_back(std::make_pair(child_idx, children.get_cell_usage()));
			// sorted_gates.push_back(std::make_pair(child_idx, children.get_intermediate_storage()));
		}
		// 默认情况下 CU值相同的时候是按照netlist中的gate的inputs_line的索引（从小到大）来排序	
		std::sort(sorted_gates.begin(), sorted_gates.end(),
		[this](const std::pair<gate_idx, unsigned int> &a, const std::pair<gate_idx, unsigned int> &b)
		{ 
			if(a.second != b.second){
				return a.second > b.second;
			}
			else{
				// if(m_gates[a.first].max_fanout_level < m_gates[b.first].mini_fanout_level){
				if(m_gates[a.first].max_fanout_level < m_gates[b.first].max_fanout_level){
					return true;
				}
				else{
					return a.first < b.first;
				}
			}
		});
		// std::sort(sorted_gates.begin(), sorted_gates.end(),[](const std::pair<gate_idx, unsigned int> &a, const std::pair<gate_idx, unsigned int> &b){ return a.second > b.second; });
		// std::stable_sort(sorted_gates.begin(), sorted_gates.end(),[](const std::pair<gate_idx, unsigned int> &a, const std::pair<gate_idx, unsigned int> &b){ return a.second > b.second; });
		for( const auto &p : sorted_gates)
		{
			if(m_gates[p.first].get_map() == 0)
			{
				if(!allocate_row(p.first))
				{
					return false;
				}
			}
		}
	}
	if(m_gates[gate_index].get_map() == 0)
	{
		int map = allocate_cell(gate_index);
		m_gates[gate_index].set_map(map);
		if(m_gates[gate_index].get_map() == 0)
		{
			return false;
		}
	}
	return true;
}

bool Magic::allocate_row_by_intermediate_storage(const gate_idx &gate_index)
{
	std::vector<std::pair<gate_idx, unsigned int>> sorted_gates;//gate_idx CU
	if(m_gates[gate_index].get_indegree() != 0)
	{
		for(const auto & input_line : m_gates[gate_index].get_inputs())
		{
			if(m_lines[input_line].is_input)
				continue;
			const gate_idx &child_idx = m_lines[input_line].source;
			Gate& children = m_gates[child_idx];
			sorted_gates.push_back(std::make_pair(child_idx, children.get_intermediate_storage()));//按照m_intermediate_storage的大小来进行选取
		}

		std::sort(sorted_gates.begin(), sorted_gates.end(),
		[this](const std::pair<gate_idx, unsigned int> &a, const std::pair<gate_idx, unsigned int> &b)
		{ 
			if(a.second != b.second){
				return a.second > b.second;
			}
			else{
				// if(m_gates[a.first].max_fanout_level < m_gates[b.first].mini_fanout_level){
				if(m_gates[a.first].max_fanout_level < m_gates[b.first].max_fanout_level){
					return true;
				}
				else{
					return a.first < b.first;
				}
			}
		});
		// std::sort(sorted_gates.begin(), sorted_gates.end(),[](const std::pair<gate_idx, unsigned int> &a, const std::pair<gate_idx, unsigned int> &b){ return a.second > b.second; });
		// std::stable_sort(sorted_gates.begin(), sorted_gates.end(),[](const std::pair<gate_idx, unsigned int> &a, const std::pair<gate_idx, unsigned int> &b){ return a.second > b.second; });
		for( const auto &p : sorted_gates)
		{
			if(m_gates[p.first].get_map() == 0)
			{
				if(!allocate_row(p.first))
				{
					return false;
				}
			}
		}
	}
	if(m_gates[gate_index].get_map() == 0)
	{
		int map = allocate_cell(gate_index);
		m_gates[gate_index].set_map(map);
		if(m_gates[gate_index].get_map() == 0)
		{
			return false;
		}
	}
	return true;
}

int Magic::allocate_cell(const gate_idx &gate_index)
{
	mapping_gates.push_back(gate_index);
	int free_cell = cellsinfo.get_first_available();
	if(free_cell == -1)//-1 means no available cells
	{
		if(cellsinfo.init_is_not_empty())
		{
			std::vector<std::pair<int, int>> inits = cellsinfo.init_list;
			std::vector<gate_idx> init_gates{};
			for(const auto& init : inits)
			{
				init_gates.push_back(init.first); 
			}
			m_micro_operation[m_time + 1] = init_gates;//store gates to be initialed
			
			cellsinfo.concatenate_init_to_available_list();
			cellsinfo.clean_init_list();
			free_cell = cellsinfo.get_first_available();
			m_reuse_cycles += 1;
			m_time += 1;
		}
		else
		{
			return 0;
		}
	}

	cellsinfo.delete_first_available();
	cellsinfo.insert_used_positive_order(free_cell, gate_index);

	m_time += 1;
	m_gates[gate_index].set_map(free_cell);
	m_gates[gate_index].set_time(m_time);
	m_micro_operation[m_time] = gate_index;

	std::vector<line_idx> input_lines = m_gates[gate_index].get_inputs();
	std::sort( input_lines.begin(), input_lines.end(), compare_input_line_index);//按照input_line_index从小到大来遍历
	for(const auto &input : input_lines)
	{
		if(m_lines[input].is_input)
		{
			continue;
		}
		gate_idx chileren_idx = m_lines[input].source;
		Gate &children = m_gates[chileren_idx];
		children.outdegree() = children.outdegree() - 1;
		if(children.get_outdegree() == 0)
		{
			cellsinfo.delete_used(children.get_map());
			cellsinfo.insert_init_positive_order(children.get_map());
		}
	}
	return free_cell;
}

void Magic::initialize_cells()
{
	assert( m_row_size >= PI_size_without_zero_one );//at least row_size >= m_inputs
	//对zero one的处理；parse的时候，将zero one解析成为了1-input,1-output的gate。
	//在mapping的时候，仅需为这个gate（也就是这个gate对应的PO）分配一个cell就可以了
	//初始化的时候，不需要为zero/one额外占据一个cell
	// int real_Pi_size = m_inputs.size();
	// if( m_zeros.size() != 0){
	// 	real_Pi_size --;
	// }
	// if( m_ones.size() != 0){
	// 	real_Pi_size --;
	// }
	for(int i = 0; i < PI_size_without_zero_one; i++)//insert used(real_pi)
	{
		cellsinfo.insert_used(i, NULL_INDEX);
	}
	// for(int i = 0; i < m_inputs.size(); i++)//insert used(PI)
	// {
	// 	cellsinfo.insert_used(i, NULL_INDEX);
	// }
	for(int i = PI_size_without_zero_one; i < m_row_size; i++)//insert available(index: from real_pi to row_size)
	{
		cellsinfo.insert_available_positive_order(i);
	}
}

void Magic::initialize_cells_for_SA( const int &cost )
{
	// assert(costRootsPair.first + PI_size_without_zero_one >= PI_size_without_zero_one );//at least row_size >= m_inputs
	assert(cost + PI_size_without_zero_one >= PI_size_without_zero_one );
	
	for(int i = 0; i < PI_size_without_zero_one; i++)//insert used(PI)
	{
		cellsinfoSA->insert_used(i, NULL_INDEX);
	}
	int row_size_SA = PI_size_without_zero_one + cost;
	for(int i = PI_size_without_zero_one; i < row_size_SA; i++)//insert available(index: from pi to row_size)
	{
		cellsinfoSA->insert_available_positive_order(i);
	}
}

void Magic::compute_roots()
{
	for(const auto& outline_idx : m_outputs)
	{
		m_roots.push_back(m_lines[outline_idx].source);
	}
}

void Magic::set_root_tree_size()
{
	std::vector<std::vector<gate_idx>> trees = get_trees_for_every_roots(m_roots);
	for(const auto &tree : trees){
		int tree_size = tree.size();
		gate_idx tree_head = tree.front();
		// gate(tree.front()).set_tree_size(tree_size);
		m_gates[tree_head].set_tree_size(tree_size);
	}
}

void Magic::print_cellsinfo()
{
	m_print("print available ");
	cellsinfo.traversal_list(cellsinfo.available_head);
	m_print("print used ");
	cellsinfo.traversal_list(cellsinfo.used_head);
	m_print("print init ");
	cellsinfo.traversal_list( cellsinfo.init_head);
}

 void Magic::print_cellsinfo_SA()
 {
	m_print("print available ");
	cellsinfoSA->traversal_list(cellsinfoSA->available_head);
	m_print("print used ");
	cellsinfoSA->traversal_list(cellsinfoSA->used_head);
	m_print("print init ");
	cellsinfoSA->traversal_list( cellsinfoSA->init_head);
}

void Magic::generate_micro_operation()
{
	m_print("********** MAPPING OF ", m_benchmark_name, " WITH ROW SIZE = ", m_row_size, "**********");
	m_Print("Benchmark: ", m_benchmark_name);
	m_Print("Row size: ", m_row_size);
	m_Print("Number of Gates: ", m_gates.size());

	std::string input_str = "Inputs: {";
	for(int i = 0; i < m_inputs.size(); i++)
	{
		std::string str = m_lines[get_inputs()[i]].name + "(" + std::to_string(i) + "),";//map of input = index of input
		if( m_lines[get_inputs()[i]].name == "one" || m_lines[get_inputs()[i]].name == "zero" )
			continue;
		input_str += str;
	}
	input_str += "}";
	m_Print(input_str);

	std::string output_str = "Outputs: {";
	for(const auto &output_line : m_outputs)
	{
		std::string str = m_lines[output_line].name + "(" + std::to_string(m_gates[m_lines[output_line].source].get_map()) + "),";
		output_str += str;
	}
	output_str += "}";
	m_Print(output_str);
	//解析的时候将zero one解析为了PI， 打印信息的时候需要去除
	m_Print("Number of Inputs: ", PI_size_without_zero_one);
	// m_Print("Number of Inputs: ", m_inputs.size());
	m_Print("Number of outputs: ", m_outputs.size());
	m_Print("Total cycles: ", m_time);
	m_Print("Reuse cycles: ", m_reuse_cycles);
	double percentage = static_cast<double>(m_reuse_cycles) / m_time * 100;
	m_Print("Reuse percentage: ", std::setprecision(2),percentage, "%");
	m_Print("Execution sequence:  ");

	std::string str = "T0: \"Initialization(Ron){ ";
	for(int i = PI_size_without_zero_one; i < m_row_size; i++)
	{
		std::string s = "INIT_CYCLE( " + std::to_string(i) + " ),";
		str += s;
	}
	str += " }";
	m_Print(str);

	for(const auto& [time, value] : m_micro_operation)
	{
		std::string gate_type{};
		std::vector<std::string> input_line_name{};//store the name of gate input_lines
		std::vector<int> cell_locations{};//store the cell_idx of gates input
		if (std::holds_alternative<gate_idx>(value))
        {
            auto gate_index = std::get<gate_idx>(value);
			std::string gate_type{};
			std::vector<std::string> input_line_name{};//store the name of gate input_lines
			std::vector<int> cell_locations{};//store the cell_idx of gates input
			if(m_gates[gate_index].get_inv1() || m_gates[gate_index].get_buf()){
				if(m_gates[gate_index].get_inv1())
					gate_type = "inv1";
				else gate_type = "buf";
				std::vector<line_idx> input_line_index = m_gates[gate_index].get_inputs();
				for(const auto &input : input_line_index)
				{
					input_line_name.push_back(m_lines[input].name);
					if(m_lines[input].is_input)
					{
						cell_locations.push_back(input);
					}
					else if(m_lines[input].is_output)
					{
						// cell_locations.push_back(input);
						gate_idx gate_index = m_lines[input].source;
						cell_locations.push_back(m_gates[gate_index].get_map());
					}
					else//is_wire
					{
						gate_idx gate_index = m_lines[input].source;
						cell_locations.push_back(m_gates[gate_index].get_map());
					}
				}
			}
			else if(m_gates[gate_index].get_nor2() || m_gates[gate_index].get_nor3() ||
			m_gates[gate_index].get_nor4() || m_gates[gate_index].get_nor5()){
				if(m_gates[gate_index].get_nor2())
					gate_type = "nor2";
				else if(m_gates[gate_index].get_nor3())
					gate_type = "nor3";
				else if(m_gates[gate_index].get_nor4())
					gate_type = "nor4";
				else if(m_gates[gate_index].get_nor4())
					gate_type = "nor5";
				std::vector<line_idx> input_line_index = m_gates[gate_index].get_inputs();
				for(const auto &input : input_line_index)
				{
					input_line_name.push_back(m_lines[input].name);
					if(m_lines[input].is_input)
					{
						cell_locations.push_back(input);
					}
					else if(m_lines[input].is_output)
					{
						// cell_locations.push_back(input);
						gate_idx gate_index = m_lines[input].source;
						cell_locations.push_back(m_gates[gate_index].get_map());
					}
					else//is_wire
					{
						gate_idx gate_index = m_lines[input].source;
						cell_locations.push_back(m_gates[gate_index].get_map());
					}
				}
			}
			else if(m_gates[gate_index].get_zero() || m_gates[gate_index].get_one())
			{
				if(m_gates[gate_index].get_zero())
					gate_type = "zero";
				else gate_type = "one";
			}
			else{
				gate_type = "no_type";
				assert(gate_type != "no_type");
			}
			std::string cycle = std::to_string(time);
			auto output_line = m_gates[gate_index].get_output();
			std::string output_line_name = m_lines[output_line].name;
			if(gate_type == "inv1")
			{
				m_Print("T", cycle, ": ", output_line_name, "(", m_gates[gate_index].get_map() , ")", "=", gate_type, "{", input_line_name[0], "(", cell_locations[0] , ")" , "}");
			}
			else if(gate_type == "nor2")
			{
				m_Print("T", cycle, ": ", output_line_name, "(", m_gates[gate_index].get_map() , ")", "=", gate_type, "{", input_line_name[0], "(", cell_locations[0] , ")", ",",  input_line_name[1], "(", cell_locations[1] , ")" , "}");
			}
			else if(gate_type == "nor3")
			{
				m_Print("T", cycle, ": ", output_line_name, "(", m_gates[gate_index].get_map() , ")", "=", gate_type, "{", input_line_name[0], "(", cell_locations[0] , ")", ",",  input_line_name[1], "(", cell_locations[1] , ")" , ",",  input_line_name[2], "(", cell_locations[2] , ")" , "}");
			}
			else if(gate_type == "nor4")
			{
				m_Print("T", cycle, ": ", output_line_name, "(", m_gates[gate_index].get_map() , ")", "=", gate_type, "{", input_line_name[0], "(", cell_locations[0] , ")", ",",  input_line_name[1], "(", cell_locations[1] , ")" , ",",  input_line_name[2], "(", cell_locations[2] , ")" , ",",  input_line_name[3], "(", cell_locations[3] , ")" , "}");
			}
			else if(gate_type == "nor5")
			{
				m_Print("T", cycle, ": ", output_line_name, "(", m_gates[gate_index].get_map() , ")", "=", gate_type, "{", input_line_name[0], "(", cell_locations[0] , ")", ",",  input_line_name[1], "(", cell_locations[1] , ")" , ",",  input_line_name[2], "(", cell_locations[2] , ")" , ",",  input_line_name[3], "(", cell_locations[3] , ")", ",",  input_line_name[4], "(", cell_locations[4] , ")" , "}");
			}
			else if(gate_type == "buf")
			{
				m_Print("T", cycle, ": ", output_line_name, "(", m_gates[gate_index].get_map() , ")", "=", gate_type, "{", input_line_name[0], "(", cell_locations[0] , ")" , "}");
			}
			else if(gate_type == "zero")
			{
				auto output_line = m_gates[gate_index].get_output();
				std::string output_name = m_lines[output_line].name;
				m_Print("assign constant input zero to PO: ", output_name); 
			}
			else if(gate_type == "one")
			{
				auto output_line = m_gates[gate_index].get_output();
				std::string output_name = m_lines[output_line].name;
				m_Print("assign constant input one to PO: ", output_name);
			}
			else
			{
				m_print("error output! ");
			}

        }
		else if(std::holds_alternative<std::vector<gate_idx>>(value))//INITIALIZE
		{
			std::string init_str = "T";
			init_str = init_str + std::to_string(time) + ":Initialization(Ron){";
			for (const auto& gate : std::get<std::vector<gate_idx>>(value))
            {
                auto output_line = m_gates[gate].get_output();
				m_lines[output_line].name;
				init_str = init_str + m_lines[ m_gates[gate].get_output()].name + "(" + std::to_string(m_gates[gate].get_map()) + "),";
            }
			init_str += "}";
			m_print(init_str);
		}
	}

}

void Magic::generate_stats( bool old_version)
{
	if( old_version )
	{
		m_print("********** MAPPING OF ", m_benchmark_name, " WITH ROW SIZE = ",m_row_size, "**********");
		m_Print("Benchmark: ", m_benchmark_name);
		m_Print("Row size: ", m_row_size);
		m_Print("Number of Gates: ", m_gates.size());
		m_Print("Number of Inputs: ", PI_size_without_zero_one);
		m_Print("Number of outputs: ", m_outputs.size());
		m_Print("Total cycles: ", m_time);
		m_Print("Reuse cycles: ", m_reuse_cycles);
		m_print("********************");
	}
	else
	{
		std::cout << "*******************************************************************************\n"
                      << "*                    SIMPLER Mapping statistics                               *\n"
                      << "*******************************************************************************\n";
            std::cout << "-------------------------------------------------------------------------------\n"
            << std::setw( 3 ) << std::left << " "
            << "| RRAMs | = " << m_row_size << std::setw( 4 ) << " "
            << "| Cycles | = " << m_time << std::setw( 4 ) << " "
            << "| Reuse Cycles | = " << m_reuse_cycles << "\n";
            std::cout << "-------------------------------------------------------------------------------\n";
	}
}

std::vector<gate_idx> Magic::topo_sort()
{
	std::vector<gate_idx> topo_orders;
	std::queue<gate_idx> q;
	std::set<gate_idx> initial_degree;
	for(auto gate : m_gates)
	{
		if(gate.get_indegree() == 0)
		{
			q.push(gate.get_id());
			topo_orders.push_back(gate.get_id());
		}
	}
	while(!q.empty())
	{
		auto u = q.front();
		q.pop();
		auto output_line = m_gates[u].get_output();
		std::set<gate_idx> adj_gartes = m_lines[output_line].destination_gates;
		for(const auto &g : adj_gartes)
		{
			if(!--m_gates[g].indegree())//
			{
				q.push(g);
				topo_orders.push_back(g);
				initial_degree.insert(g);
			}
		}
	}
	for(const auto &gate : initial_degree)
	{
		int fanin = m_gates[gate].get_fanin();
		m_gates[gate].set_in_degree(fanin);
	}
	assert(topo_orders.size() == m_gates.size());
	return topo_orders;
}

std::vector<std::vector<gate_idx>> Magic::enum_topo_sort()
{
    std::vector<std::vector<gate_idx>> all_orders;
    std::vector<gate_idx> cur_order;
    std::unordered_set<gate_idx> visited;
    enum_topo_sort_helper(all_orders, cur_order, visited);
	for(auto &all_order : all_orders){
		std::reverse(all_order.begin(), all_order.end());
	}
	return all_orders;
}

void Magic::enum_topo_sort_helper(std::vector<std::vector<gate_idx>> &all_orders, std::vector<gate_idx> &cur_order, std::unordered_set<gate_idx> &visited)
{
    if (cur_order.size() == m_gates.size()) {
        all_orders.push_back(cur_order);
        return;
    }
    for (auto gate : m_gates) {
        if (visited.count(gate.get_id()) == 0 && gate.get_indegree() == 0) {
            visited.insert(gate.get_id());
            cur_order.insert(cur_order.begin(), gate.get_id());
            auto output_line = gate.get_output();
            std::set<gate_idx> adj_gates = m_lines[output_line].destination_gates;
            for (const auto &g : adj_gates) {
                --m_gates[g].indegree();
            }
            enum_topo_sort_helper(all_orders, cur_order, visited);
            for (const auto &g : adj_gates) {
                ++m_gates[g].indegree();
            }
            cur_order.erase(cur_order.begin());
            visited.erase(gate.get_id());
        }
    }
}

std::pair<int, int> Magic::cost_function(const std::vector<gate_idx> &topo)//max_intermediate_storage, i
{
	int max_intermediate_storage = 0;
	int i = 0;
	std::set<gate_idx> initial_degree;//
	for(const auto &to : topo){
		// m_print(m_gates[to].get_name(), m_gates[to].get_indegree_2());//
		// std::cout << m_gates[to].get_name() << "," << m_gates[to].get_indegree_2() << "," << m_gates[to].get_outdegree_2() << std::endl;
		if(m_gates[to].get_indegree() == 0){//if(m_gates[to].get_indegree() == 0)应该修改为这个，修改cost的问题
			i++;
			if(i > max_intermediate_storage)
				max_intermediate_storage = i;
		}
		else{
			i++;
			if(i > max_intermediate_storage)
				max_intermediate_storage = i;
			std::vector<line_idx> input_lines = m_gates[to].get_inputs();

			for(const auto &input : input_lines)
			{
				if(m_lines[input].is_input)
					continue;
				if(m_lines[input].is_output)
					continue;	
				gate_idx chileren_idx = m_lines[input].source;
				initial_degree.insert(chileren_idx);
				Gate &children = m_gates[chileren_idx];
				// m_print("in cost_function", children.get_name(), children.get_outdegree_2());//
				children.outdegree_2() = children.outdegree_2() - 1;
				// m_print("in cost_function", children.get_name(), children.get_outdegree_2());//
				if(children.get_outdegree_2() == 0){
					i--;
				}
			}
		}
		// m_print("i", i);
	}
	for(const auto & initial : initial_degree)
	{
		int fanout = m_gates[initial].get_fanout();
		m_gates[initial].set_out_degree_2(fanout);
	}

	return std::make_pair(max_intermediate_storage, i);
	//i 处理完最后一个节点后占据的RRAM的数量
	//对于fanout!=0的root节点，不会被算在final RRAMs里面，因为它作为其余root节点的root节点，fanou==0之后就不被计数了，例如half_adder中的cout
	//inputs.size() + Min[max_intermediate_storage] This is the smallest number of memristors that can be obtained
}

int Magic::cost_function_RL(const std::vector<gate_idx> &topo)//return cost
{
	int max_intermediate_storage = 0;
	int i = 0;
	std::set<gate_idx> initial_degree;
	for(const auto &to : topo){
		if(m_gates[to].get_indegree() == 0){
			i++;
			if(i > max_intermediate_storage)
				max_intermediate_storage = i;
		}
		else{
			i++;
			if(i > max_intermediate_storage)
				max_intermediate_storage = i;
			std::vector<line_idx> input_lines = m_gates[to].get_inputs();
			
			std::vector<gate_idx> childs_po_eq_zero{};
			for(const auto &input : input_lines)
			{
				if(m_lines[input].is_input)
					continue;
				if(m_lines[input].is_output)
					continue;
				gate_idx children_idx = m_lines[input].source;
				initial_degree.insert(children_idx);
				Gate &children = m_gates[children_idx];
				children.outdegree_2() = children.outdegree_2() - 1;
				if(children.get_outdegree_2() == 0)
				{
					i--;
				}
			}
		}
	}
	for(const auto & initial : initial_degree)
	{
		int fanout = m_gates[initial].get_fanout();
		m_gates[initial].set_out_degree_2(fanout);
	}

	return max_intermediate_storage;
}

int Magic::compute_EIC(const gate_idx& gate)
{
	//EIC = include cost - released cost
	int RRAM_released = 0;
	int RRAM_included = 1;
	if(m_gates[gate].get_fanin() == 0)//EIC = 1, for node's fanin all connect to PI
		return 1;
	for(const auto & children_index : m_gates[gate].get_inputs())
	{
		if(m_lines[children_index].is_input)
			continue;
		Gate &children = m_gates[m_lines[children_index].source];
		--children.outdegree_3();
		if(children.get_outdegree_3() == 0);
			RRAM_released++;
	}
	return RRAM_included - RRAM_released;
}

std::vector<gate_idx> Magic::GreedyExecutionSequence()
{
	std::vector<gate_idx> sequence;
	std::vector<int> Memo;
	Memo.push_back(std::numeric_limits<int>::max());
	int gates_num = m_gates.size();
	int M = 10;//iterations
	for(int i = 0; i <= M; i++){
		
		std::vector<gate_idx> candidate_sequence, candidates;
		std::pair<int, int> cost;//需要考虑一下
		std::vector<gate_idx> initial_indegree;//存在重复，可以改为set

		for(const auto& gate : m_gates)
		{
			if(gate.get_indegree() == 0)
			{
				candidates.push_back(gate.get_id());
			}
		}
		while(candidate_sequence.size() != gates_num)
		{
			std::map<gate_idx, int> effective_include_cost;
			std::vector<gate_idx> minium_EICs;

			for(const auto &gate : candidates)
			{
				int EIC = compute_EIC(gate);
				effective_include_cost.insert(std::make_pair(gate, EIC));
			}

			int min_value = std::numeric_limits<int>::max();
			for (const auto& pair : effective_include_cost)
			{
				if (pair.second < min_value) 
				{
					min_value = pair.second;
					minium_EICs.clear(); 
					minium_EICs.push_back(pair.first);
        		} else if (pair.second == min_value) 
				{
            		minium_EICs.push_back(pair.first);
        		}
			}
			std::random_device rd;
			std::mt19937 gen(rd());
			std::uniform_int_distribution<std::size_t> dist(0, minium_EICs.size() - 1);
    		std::size_t random_index = dist(gen);
			candidate_sequence.push_back(minium_EICs[random_index]); 
			std::vector<gate_idx>::iterator it = std::find(candidates.begin(), candidates.end(), minium_EICs[random_index]);
			gate_idx node_selected = *it; 
			candidates.erase(it);

			line_idx output_line = m_gates[node_selected].get_output();
			std::set<gate_idx> output_gates = m_lines[output_line].destination_gates;
			for(const auto & output_gate : output_gates)
			{
				initial_indegree.push_back(output_gate);
				--m_gates[output_gate].indegree_2();
				if(m_gates[output_gate].get_indegree_2() == 0)
					candidates.push_back(output_gate);
			}
			// cost = cost_function(candidate_sequence);
			// 		std::cout << " Cost " << cost.first << std::endl;
			//cost出问题的原因在于，当序列大小为gates.size()的时候，in_degree_2才会被修复，
			//但是在candidate_sequence < gates.size()的时候，cost_function中的判断条件不能使用in_degerr_2来判断
			if(cost.first >= *std::min_element(Memo.begin(), Memo.end()))
				break;
		}
		for(const auto & initial : initial_indegree)
		{
			int fanin = m_gates[initial].get_fanin();
			m_gates[initial].set_in_degree_2(fanin);
		}
		for(auto & gate : m_gates)
		{
			int fanout = gate.get_fanout();
			gate.set_out_degree_3(fanout);
		}

		cost = cost_function(candidate_sequence);
		std::cout << " cost_function(candidate_sequence).first " << cost.first
		<< " *std::min_element(Memo.begin(), Memo.end()) " << *std::min_element(Memo.begin(), Memo.end()) << std::endl;

		if(cost.first < *std::min_element(Memo.begin(), Memo.end()))//cost.first
			sequence = candidate_sequence;
		Memo.push_back(cost.first);
	}
	return sequence;
}

std::vector<gate_idx> Magic::parse_from_result(std::istream &is, int index)
{
	const std::string flag = ";";
	std::vector<gate_idx> result_gateidx;
	int result_index = index;//指定获得第n个benchmark的结果 1开始
	int count = 0;
	std::string previous_line;

	for (std::string line; std::getline(is, line, '\n');)
	{
		if(line.find(flag) != std::string::npos)
		{
			count++;
			if(result_index == count)
			{
				std::vector<std::string> result_string = m_split(line, flag);
				for(auto & str : result_string)
				{
					result_gateidx.push_back(std::stoi(str));
				}
				break;
			}
		}
		previous_line = line;
		//TODO 可以修改返回值类型为 std::vector<vector<gate_idx>> 一次得出所有的结果
	}
	std::cout << "Previous line: " << previous_line << std::endl;
	return result_gateidx;
}

bool Magic::VecGateAPI(const std::vector<gate_idx> &gates)
{
 	for(const auto &gate : gates)
	{
		int map = allocate_cell(gate);
		m_gates[gate].set_map(map);
		if(m_gates[gate].get_map() == 0)
		{
			return false;
		}
	}
	return true;
}

void Magic::getFanoutLevelforGates()
{

	int total_fanout_level{};


	for(auto &gate : m_gates)
	{
		std::vector<node_degree> degrees;
		line_idx output_line = gate.get_output();
		std::set<gate_idx> output_gates = m_lines[output_line].destination_gates;
		for(const auto& output_gate : output_gates)
		{
			int level = m_gates[output_gate].get_level();
			degrees.push_back(level);
		}
		// std::sort(degrees.begin(), degrees.end());
		std::stable_sort(degrees.begin(), degrees.end());
		if(degrees.size() == 0){	//无扇出
			// gate.max_fanout_level = max_logic_depth + 1; 
			// gate.mini_fanout_level = max_logic_depth + 1;
			gate.max_fanout_level = 0;
			gate.mini_fanout_level = 0;
		}
		else{
			gate.max_fanout_level = degrees.back() + 1;
			gate.mini_fanout_level = degrees.front() + 1;
			
			//sum of all fo_level for a node
			int sum = 0;
			for(const auto & degree : degrees)
			{
				int level = degree + 1;
				sum += level;
			}
			total_fanout_level += sum;

		}
	}

	set_fo_lev_ave( static_cast<float>(total_fanout_level) / (m_gates.size()) );
}

void Magic::getFanoutNodeNumforGates()
{
	int total_fanout_node = 0;
	int total_fanout_node_2 = 0;
	int total_fanin_node = 0;
	std::vector<int> node_fanout_num{}; //The number of fanouts for each gate.
	for(auto &gate : m_gates)
	{
		total_fanout_node += gate.get_fanout();
		node_fanout_num.push_back( gate.get_fanout() );
		total_fanin_node += gate.get_fanin();
	}
	std::sort( node_fanout_num.begin(), node_fanout_num.end() );
	int max_fanout_num = node_fanout_num.back();

	set_fo_node_num_max( max_fanout_num );
	set_fo_node_num_ave( ( static_cast<float>(total_fanout_node) / (m_gates.size()) ) ); //"To avoid integer division and retain decimals."
	set_fanin_node_num_ave( ( static_cast<float>(total_fanin_node) / (m_gates.size()) ) );
}

std::vector<gate_idx> Magic::RootsToGates(const std::vector<gate_idx> &roots)
{
	std::vector<gate_idx> results;
	std::unordered_set<gate_idx> visited;
	for(const auto & gate : roots)
	{
		ToGates(gate, results, visited);
	}
	return results;
}

void Magic::ToGates(const gate_idx &gate_index, std::vector<gate_idx> &gates, std::unordered_set<gate_idx> &visited)//modifiable
{
	std::vector<std::pair<gate_idx, unsigned int>> sorted_gates;//gate_idx CU or gate_index m_intermediate_storage
	if(m_gates[gate_index].get_indegree() != 0)
	{
		for(const auto & input_line : m_gates[gate_index].get_inputs())
		{
			if(m_lines[input_line].is_input)
				continue;
			const gate_idx &child_idx = m_lines[input_line].source;
			Gate& children = m_gates[child_idx];
			// sorted_gates.push_back(std::make_pair(child_idx, children.get_cell_usage()));
			sorted_gates.push_back(std::make_pair(child_idx, children.get_intermediate_storage()));
		}
		std::sort(sorted_gates.begin(), sorted_gates.end(),
		[this](const std::pair<gate_idx, unsigned int> &a, const std::pair<gate_idx, unsigned int> &b)
		{ 
			if(a.second != b.second){
				return a.second > b.second;
			}
			else{
				// if(m_gates[a.first].max_fanout_level < m_gates[b.first].mini_fanout_level){
				if(m_gates[a.first].max_fanout_level < m_gates[b.first].max_fanout_level){
					return true;
				}
				else{
					return a.first < b.first;
				}
			}
		});
		for( const auto &p : sorted_gates)
		{
			if(!visited.count(p.first))
			{
				ToGates(p.first, gates, visited);
			}
		}
	}
	if(!visited.count(gate_index))
	{
		gates.push_back(gate_index);
		visited.emplace(gate_index);
	}
}

void Magic::RandomExchange(std::vector<gate_idx> & roots)
{
	std::random_device rd;
	std::mt19937 gen(rd());
	std::uniform_int_distribution<std::size_t> dist(0, roots.size() - 1);
	std::size_t random_index1 = dist(gen);
	std::size_t random_index2 = dist(gen);
	while (random_index1 == random_index2)
	{
		random_index2 = dist(gen);
	}
	std::swap(roots[random_index1], roots[random_index2]);
}

double RandomZeroToOne()
{
	std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> dis(0.0, 1.0);
    double randomValue = dis(gen);
	return randomValue;
}

int factorial(int n) {
    return (n == 0 || n == 1) ? 1 : n * factorial(n - 1);
}

int enter = 0;
int enter1 = 0;
std::pair<int, std::vector<gate_idx>> Magic::SimulatedAnnealing( bool show_progress )//cost,Roots
{
	// int upbound = 0;
	// if(m_outputs.size() <= 8)
	// 	upbound = factorial(m_outputs.size());
	
	if(m_outputs.size() == 1)//for single PO,do not use SA algo
	{
		std::vector<gate_idx> initializeRoots = m_roots;
		std::vector<gate_idx> initializeGates = RootsToGates(initializeRoots);
		assert(initializeGates.size() == m_gates.size());//eusure include all gates
		int old_cost = cost_function(initializeGates).first;
		return std::make_pair(old_cost, initializeRoots);
	}
	else	
	{
		std::vector<gate_idx> initializeRoots = m_roots;
		std::vector<gate_idx> currentRoots = initializeRoots;//keep initializeRoots
		std::vector<gate_idx> initializeGates = RootsToGates(initializeRoots);
		assert(initializeGates.size() == m_gates.size());//eusure include all gates
		int old_cost = cost_function(initializeGates).first;
		// double initialTemp = 10, finalTemp = 0.01, a = 0.98;
		double initialTemp = 10, finalTemp = 0.01, a = 0.9;
		double tempRange = initialTemp - finalTemp;
		double initialTemp_back = initialTemp;
		int unchangeCount = 0;
		std::cout << "\n";
		while (initialTemp > finalTemp)
		{
			double progress = ( initialTemp_back - initialTemp ) / tempRange;
			if( show_progress )
				printProgress( progress );
			enter1++;
			int i = 1;
			while(i < 1000)//
			{
				enter++;
				RandomExchange(initializeRoots);
				std::vector<gate_idx> gates = RootsToGates(initializeRoots);
				assert(gates.size() == m_gates.size());//make sure ES includes all gates
				int new_cost = cost_function(gates).first;
				double accp_prob = exp((old_cost - new_cost) / initialTemp);
				double randomValue = RandomZeroToOne();
				if(accp_prob > randomValue)
				{
					old_cost = new_cost;
					currentRoots = initializeRoots;//when accepted, update Roots
				}
				if(new_cost == old_cost)
				{
					unchangeCount++;
				}
				else
				{
					unchangeCount = 0;
				}
				i++;
			}
			initialTemp = initialTemp * a;
			// if(unchangeCount >= 50)
			// {
			// 	std::cout << "Exiting due to consecutive unchanged costs." << std::endl;
			// 	break;  
			// }
			// if(m_outputs.size() <= 8 && enter >= upbound)
			// 	break;
		}
		if( show_progress )
			printProgress( 1.0 );
		std::cout << "\n";
		return std::make_pair(old_cost, currentRoots);
	}
}

void Magic::mapping_for_SA( const std::vector<gate_idx> &roots_order )
{
	for(const auto & root : roots_order)
	{
		allocate_row_for_SA(root);
	}
}

void Magic::allocate_row_for_SA( const gate_idx &gate_index )
{
	std::vector<std::pair<gate_idx, unsigned int>> sorted_gates;//gate_index, intermediate_storage
	if(m_gates[gate_index].get_indegree() != 0)
	{
		for(const auto & input_line : m_gates[gate_index].get_inputs())
		{
			if(m_lines[input_line].is_input)
				continue;
			const gate_idx &child_idx = m_lines[input_line].source;
			Gate& children = m_gates[child_idx];
			sorted_gates.push_back(std::make_pair(child_idx, children.get_intermediate_storage()));
			// sorted_gates.push_back(std::make_pair(child_idx, children.get_cell_usage()));
		}	
		std::sort(sorted_gates.begin(), sorted_gates.end(),
		[this](const std::pair<gate_idx, unsigned int> &a, const std::pair<gate_idx, unsigned int> &b)
		{ 
			if(a.second != b.second){
				return a.second > b.second;
			}
			else{
				if(m_gates[a.first].max_fanout_level < m_gates[b.first].max_fanout_level){
					return true;
				}
				else{
					return a.first < b.first;
				}
			}
		});
		for( const auto &p : sorted_gates)
		{
			if(m_gates[p.first].get_map_SA() == 0)
			{
				allocate_row_for_SA(p.first);
			}
		}
	}
	if(m_gates[gate_index].get_map_SA() == 0)
	{
		int map = allocate_cell_for_SA(gate_index);
		m_gates[gate_index].set_map_SA(map);
		if(m_gates[gate_index].get_map_SA() == 0)
		{
			assert(false);
		}
	}	
}

int Magic::allocate_cell_for_SA(const gate_idx &gate_index)
{
	mapping_gates_SA.push_back(gate_index);
	int free_cell = cellsinfoSA->get_first_available();
	if(free_cell == -1)//-1 means no available cells
	{
		if(cellsinfoSA->init_is_not_empty())
		{
			std::vector<std::pair<int, int>> inits = cellsinfoSA->init_list;
			std::vector<gate_idx> init_gates{};
			for(const auto& init : inits)
			{
				init_gates.push_back(init.first); 
			}
			m_micro_operation_SA[m_time_SA + 1] = init_gates;//store gates to be initialed
			
			cellsinfoSA->concatenate_init_to_available_list();
			cellsinfoSA->clean_init_list();
			free_cell = cellsinfoSA->get_first_available();
			m_reuse_cycles_SA += 1;
			m_time_SA += 1;
		}
		else
		{
			std::cout << "hello magic\n";
			return 0;
		}
	}

	cellsinfoSA->delete_first_available();
	cellsinfoSA->insert_used_positive_order(free_cell, gate_index);

	m_time_SA += 1;
	// m_print(m_time);
	m_gates[gate_index].set_map_SA(free_cell);
	m_gates[gate_index].set_time_SA(m_time_SA);
	m_micro_operation_SA[m_time_SA] = gate_index;

	std::vector<line_idx> input_lines = m_gates[gate_index].get_inputs();
	std::sort( input_lines.begin(), input_lines.end(), compare_input_line_index );
	for(const auto &input : input_lines)
	{
		if(m_lines[input].is_input)
			continue;
		if(m_lines[input].is_output)
			continue;
		gate_idx chileren_idx = m_lines[input].source;
		Gate &children = m_gates[chileren_idx];
		children.outdegree_SA() = children.outdegree_SA() - 1;
		if(children.get_outdegree_SA() == 0)
		{
			cellsinfoSA->delete_used(children.get_map_SA());
			cellsinfoSA->insert_init_positive_order(children.get_map_SA());
		}
	}
	return free_cell;
}

void Magic::compute_gate_outdegree()
{
	for(auto &gate : m_gates)
	{
		auto output_line = gate.get_output();
		Line &temp = m_lines[output_line];
		std::set<gate_idx> out_gates = temp.destination_gates;
		gate.set_out_degree(out_gates.size());
		gate.set_out_degree_SA(out_gates.size());
		gate.set_fanout(out_gates.size());
		gate.set_out_degree_2(out_gates.size());
		gate.set_out_degree_3(out_gates.size());
	}
}

void Magic::compute_gate_indegree()
{
	for(const auto& gate : m_gates)
	{
		auto output_line = gate.get_output();
		Line &temp = m_lines[output_line];
		for(auto &out_gate : temp.destination_gates)
		{
			m_gates[out_gate].set_in_degree(++m_gates[out_gate].indegree());
			m_gates[out_gate].set_in_degree_2(++m_gates[out_gate].indegree_2());
			m_gates[out_gate].set_fanin(++m_gates[out_gate].fanin()); 
			//Increase on top of the previous fan-in count
		}
		//assert(gate.get_indegree() <= 2);//fanin must <=2
	}
}

void Magic::get_nodes_for_fanout_count()
{
	for(const auto& gate : m_gates)
	{
		std::cout << gate.get_outdegree() << ", " << gate.get_id() << std::endl;
		if(gate.get_outdegree() > max_fanout_number)
			max_fanout_number = gate.get_outdegree();
	}
	m_node_fanout.resize(max_fanout_number + 1);
	for(const auto& gate : m_gates)
	{
		m_node_fanout[gate.get_outdegree()].push_back(gate.get_id());
	}
	int i = 0;
	for(const auto &node_fanout : m_node_fanout)
	{
		std::cout << "number of gates with an outdegree of " << i << " : " << node_fanout.size() << std::endl;
		for(const auto& fanout : node_fanout)
		{
			std::cout << fanout << ",";
		}
		i++;
		std::cout << std::endl;
	}
	m_print("max_fanout_number", max_fanout_number);
}

line_idx Magic::ensure_line(const std::string& name)
{
	auto it = m_name_to_line_idx.find(name);

	if (it != m_name_to_line_idx.end()) {
		return it->second;
	}

	m_lines.emplace_back();
	Line& line = m_lines.back();

	line.name = name;
	line.id_line = m_lines.size() - 1;

	m_name_to_line_idx[name] = m_lines.size() - 1;

	return line.id_line;
}

void Magic::print_graph()
{
  for (unsigned i = 0, length = m_inputs.size(); i < length; i++) {
    std::cout << "INPUT(" << m_lines[m_inputs[i]].name << ")" << std::endl;
  }
  for (unsigned i = 0, length = m_outputs.size(); i < length; i++) {
    std::cout << "OUTPUT(" << m_lines[m_outputs[i]].name << ")" << std::endl;
  }
  int level = -1;
  std::cout << "*************************************" << std::endl;
  for(const auto& t1 : m_node_level)
  {
  	level++;
  	std::cout << "lev = " << level << " : ";
  	for(const auto& t2 : t1)
  	{
  		std::cout << m_gates[t2].get_name() << " ";
  	}
  	std::cout << std::endl;
  }
  for(const auto& line : m_lines)
  {
  	std::cout << "*************************************" << std::endl;
  	std::cout << "name: " << line.name << "   ";
	if(line.is_input)
	{
		std::cout << "input" << "    /";
		std::cout << "destination_gates:  ";
  		for(const auto& gate : line.destination_gates)
		{
			std::cout << m_gates[gate].get_name() << " ";
		}
  		std::cout << std::endl;
	}
	else if(line.is_output)
	{
		if(line.source != NULL_INDEX)//
		{
			std::cout << "source:    " << m_gates[line.source].get_name() << std::endl;
		}
		if(!line.destination_gates.empty())
		{
			std::cout << "destination_gates:  ";
  			for(const auto& gate : line.destination_gates)
  			std::cout << m_gates[gate].get_name() << " ";
  			std::cout << std::endl;
		}
	}
	else
	{
		std::cout << "wire" << "    /";
		std::cout << "source:    " << m_gates[line.source].get_name() << std::endl;
		std::cout << "destination_gates:  ";
  		for(const auto& gate : line.destination_gates)
		{
			std::cout << m_gates[gate].get_name() << " ";
		}
  		std::cout << std::endl;
	}
  }
}

void Magic::print_container(bool lines, bool inputs, bool outputs, bool wires, bool gates, bool inv1s, bool nor2s)
{
	if(lines)
	{
		std::cout << "vector<Line> m_lines size:" << m_lines.size() << std::endl;
		for(const auto& line : m_lines)
		{
			std::cout << "line " << line.name << "  line_idx  " << line.id_line << std::endl;
		}
	}
	if(inputs)
	{
		std::cout << "vector<line_idx> m_inputs size:" << m_inputs.size() << std::endl;
		for(const auto& input : m_inputs)
		{
			const Line& temp = m_lines[input];
			if(!temp.is_input)
			{
				std::cout << "Abnormal input line!" << std::endl;
				return;
			}
			assert(temp.source == NULL_INDEX);//ensure PI has no source
			std::cout << "input " << temp.name << "  line_idx  " << input << std::endl;
		}
	}
	if(outputs)
	{
		std::cout << "vector<line_idx> m_outputs size:" << m_outputs.size() << std::endl;
		for(const auto& output : m_outputs)
		{
			const Line& temp = m_lines[output];
			if(!temp.is_output)
			{
				std::cout << "Abnormal output line!" << std::endl;
				return;
			}
			std::cout << "output " << temp.name << "  line_idx  " << output << std::endl;
		}
	}
	if(wires)
	{
		std::cout << "vector<line_idx> m_wires size:" << m_wires.size() << std::endl;
		for(const auto& wire :m_wires)
		{
			std::cout << "wire " << get_line(wire).name << "  line_idx  " << wire << std::endl;
		}
	}
	if(gates)
	{
		std::cout << "vector<Gate> m_gates size:" << m_gates.size() << std::endl;
		for(const auto& gate : m_gates)
		{
			std::cout << "gate " << gate.get_name() << "  gate_idx  " << gate.get_id() << std::endl;
			if(gate.get_inv1())
			{
				std::cout << "inv1" << std::endl;
			}
			else if(gate.get_nor2())
			{
				std::cout << "nor2" << std::endl;
			}
			else
			{
				std::cout << gate.get_name() << "has no gate type! " << std::endl;
			}
		}
	}
	if(inv1s)
	{
		std::cout << "vector<gate_idx> m_inv1s size:" << m_inv1s.size() << std::endl;
		for(const auto& inv1 : m_inv1s)
		{
			const Gate &temp = m_gates[inv1];
			if(!temp.get_inv1())
			{
				std::cout << "Abnormal inv1!" << std::endl;
				return;
			}
			std::cout << "inv1 " << temp.get_name() << "  gate_idx  " << temp.get_id() << std::endl;
		}
	}
	if(nor2s)
	{
		std::cout << "vector<gate_idx> m_nor2s size:" << m_nor2s.size() << std::endl;
		for(const auto& nor2 : m_nor2s)
		{
			const Gate &temp = m_gates[nor2];
			if(!temp.get_nor2())
			{
				std::cout << "Abnormal nor2!" << std::endl;
				return;
			}
			std::cout << "nor2 " << temp.get_name() << "  gate_idx  " << temp.get_id() << std::endl;
		}
	}
}

void  Magic::save_print_container(bool lines, bool gates, bool inputs, bool outputs, bool wires, bool inv1s, bool nor2s, std::string file_path )
{
	std::ofstream ofs;
	ofs.open(file_path, std::ios::out);
	if(lines)
	{
		ofs << "vector<Line> m_lines size:" << m_lines.size() << std::endl;
		for(const auto& line : m_lines)
		{
			ofs << "line " << line.name << "  line_idx  " << line.id_line << " source index: " << line.source << std::endl;
		}
	}
	if(inputs)
	{
		ofs << "vector<line_idx> m_inputs size:" << m_inputs.size() << std::endl;
		for(const auto& input : m_inputs)
		{
			const Line& temp = m_lines[input];
			if(!temp.is_input)
			{
				ofs << "Abnormal input line!" << std::endl;
				return;
			}
			ofs << "input " << temp.name << "  line_idx  " << input << std::endl;
		}
	}
	if(outputs)
	{
		ofs << "vector<line_idx> m_outputs size:" << m_outputs.size() << std::endl;
		for(const auto& output : m_outputs)
		{
			const Line& temp = m_lines[output];
			if(!temp.is_output)
			{
				ofs << "Abnormal output line!" << std::endl;
				return;
			}
			ofs << "output " << temp.name << "  line_idx  " << output << std::endl;
		}
	}
	if(wires)
	{
		ofs << "vector<line_idx> m_wires size:" << m_wires.size() << std::endl;
		for(const auto& wire :m_wires)
		{
			ofs << "wire " << get_line(wire).name << "  line_idx  " << wire << std::endl;
		}
	}
	if(gates)
	{
		ofs << "vector<Gate> m_gates size:" << m_gates.size() << std::endl;
		for(const auto& gate : m_gates)
		{
			ofs << "gate " << gate.get_name() << "  gate_idx  " << gate.get_id() << " output index: " << gate.get_output() << std::endl;
			if(gate.get_inv1())
			{
				ofs << "inv1" << std::endl;
			}
			else if(gate.get_nor2())
			{
				ofs << "nor2" << std::endl;
			}
			else
			{
				ofs << gate.get_name() << "has no gate type! " << std::endl;
			}
		}
	}
	if(inv1s)
	{
		ofs << "vector<gate_idx> m_inv1s size:" << m_inv1s.size() << std::endl;
		for(const auto& inv1 : m_inv1s)
		{
			const Gate &temp = m_gates[inv1];
			if(!temp.get_inv1())
			{
				ofs << "Abnormal inv1!" << std::endl;
				return;
			}
			ofs << "inv1 " << temp.get_name() << "  gate_idx  " << temp.get_id() << std::endl;
		}
	}
	if(nor2s)
	{
		ofs << "vector<gate_idx> m_nor2s size:" << m_nor2s.size() << std::endl;
		for(const auto& nor2 : m_nor2s)
		{
			const Gate &temp = m_gates[nor2];
			if(!temp.get_nor2())
			{
				ofs << "Abnormal nor2!" << std::endl;
				return;
			}
			ofs << "nor2 " << temp.get_name() << "  gate_idx  " << temp.get_id() << std::endl;
		}
	}
	ofs.close();
}

void Magic::write_dot( const std::string &node_lable, const std::string &file_path, bool generate_png, bool show_graph) //node_lable ("CU" Or "IS") 
{
	std::vector<std::string> PO_names_zero;
	std::vector<std::string> PO_names_one;
	std::vector<gate_idx> const_gates;//存储const gate的索引 从rank中剔除

	std::string file_name;
	if(!file_path.empty())
	{
		if(!std::filesystem::exists(file_path))
		{
			m_print("file_path not exit, create", file_path);
			std::filesystem::create_directories( file_path );
		}
		if( file_path.back()  == '/' )
		{
			// file_name = file_path + m_benchmark_name + + "_" + node_lable + ".dot";
			file_name = file_path + "netlist_DAG" + ".dot"; // only for magic_gui.py
		}
		else
		{
			// file_name = file_path + "/" + m_benchmark_name + + "_" + node_lable + ".dot";
			file_name = file_path + "/" + "netlist_DAG" + ".dot"; // only for magic_gui.py
		}
	}
	else
	{
		std::string home_dir = get_home_dir();
		file_name = home_dir + "/" + m_benchmark_name + + "_" + node_lable + ".dot";
	}
	std::fstream ofs;
	ofs.open(file_name, std::ios::out);

	ofs << "digraph{" << std::endl;
	ofs << "rankdir = BT" << std::endl;
	for(const auto& input : m_inputs)
	{
		//PI
		std::string input_name = m_lines[input].name;
		if(input_name.find("\\") != std::string::npos 
		|| input_name.find("[") != std::string::npos 
		|| input_name.find("]") != std::string::npos){
			ofs << "\"" << input_name << "\"" << " [shape=triangle,label=" << "\"" << input_name << "\"" << "];" << std::endl;
			continue;
		}
		if(input_name == "one" || input_name == "zero")
			continue;
		ofs << input_name << " [shape=triangle,label=" << input_name << "];" << std::endl;
	}
	// if(m_zeros.size() != 0 || m_ones.size() != 0)//const node(0 default)
	// {
	// 	ofs << "const [shape=box, style = filled, label=0];" << std::endl;
	// }
	ofs << "const [shape=box, style = filled, label=0];" << std::endl;//const node(0 default)
	//Gates
	for(const auto &gate : m_gates)
	{
		std::string gate_name = gate.get_name();
		std::vector<std::string> children_name;
		for(const auto &input : gate.get_inputs())
		{
			if(m_lines[input].is_input){
				std::string child_name = m_lines[input].name;
				children_name.push_back(child_name);
			}
			else{
				std::string child_name = m_gates[m_lines[input].source].get_name();
				children_name.push_back(child_name);
			}

		}
		//set node_lable in dot
		std::string lable{};
		if( node_lable == "CU" )
		{
			std::string CU = std::to_string(gate.get_cell_usage());
			lable = gate_name + "_" + CU;
		}
		else if( node_lable == "IS" )
		{
			std::string IS = std::to_string(gate.get_intermediate_storage());
			lable = gate_name + "_" + IS;
		}
		else
		{
			std::cerr << "[Error] This node lable does not exist, set IS or CU\n";
			assert( false );
		}
		if(gate.get_inv1()){
			ofs << gate_name << " [shape=oval, style = filled, label=" << lable << ", fillcolor = green];" << std::endl;
		}
		else if( gate.get_nor2() || gate.get_nor3()|| gate.get_nor4()|| gate.get_nor5() ){
			ofs << gate_name << " [shape=oval, style = filled, label=" << lable << ", fillcolor = salmon];" << std::endl;
		}
		else if( gate.get_buf() ){
			ofs << gate_name << " [shape=oval, style = filled, label=" << lable << ", fillcolor = blue];" << std::endl;//blue means buf
		}
		else if(gate.get_one()){
			auto output_index = gate.get_output();
			auto output_name = m_lines[output_index].name;
			PO_names_one.push_back(output_name);
			const_gates.push_back(gate.get_id());
			continue;
		}
		else if(gate.get_zero()){
			auto output_index = gate.get_output();
			auto output_name = m_lines[output_index].name;
			PO_names_zero.push_back(output_name);
			const_gates.push_back(gate.get_id());
			continue;
		}
		else{
			assert(false);
		}
		for(const auto& child : children_name)
		{
			if(child.find("\\") != std::string::npos 
			|| child.find("[") != std::string::npos 
			|| child.find("]") != std::string::npos){
				ofs << "\"" << child << "\"" << " -> " << gate_name << std::endl;
				continue;;
			}
			ofs << child << " -> " << gate_name << std::endl;
		}
	}
	//PO
	for(const auto & output : m_outputs)
	{
		std::string output_name = m_lines[output].name;
		if(output_name.find("\\") != std::string::npos 
		|| output_name.find("[") != std::string::npos 
		|| output_name.find("]") != std::string::npos){
			ofs << "\"" << output_name << "\"" << " [shape=invtriangle, label= " << "\"" << output_name << "\"" << "];" << std::endl;
			ofs << m_gates[m_lines[output].source].get_name() << " -> " << "\"" << output_name << "\"" << std::endl;
			continue;
		}
		ofs << output_name << " [shape=invtriangle, label= " << "\"" << output_name << "\"" << "];" << std::endl;
		auto it_1 = std::find(PO_names_one.begin(), PO_names_one.end(), output_name);
		auto it_2 = std::find(PO_names_zero.begin(), PO_names_zero.end(), output_name);
		if(it_1 != PO_names_one.end())
			ofs << "const  -> " << output_name << " [style=dashed];" <<std::endl;
		else if(it_2 != PO_names_zero.end())
			ofs << "const  -> " << output_name << std::endl;
		else
		{
			ofs << m_gates[m_lines[output].source].get_name() << " -> " << output_name << std::endl;
		}
	}
	//rank
	std::string str = "{rank = same;";
	for(const auto& input : m_inputs)
	{
		std::string input_name = m_lines[input].name;
		if(input_name.find("\\") != std::string::npos 
		|| input_name.find("[") != std::string::npos 
		|| input_name.find("]") != std::string::npos){
			str = str + " " + "\"" + input_name + "\"" + ";";
			continue;
		}
		if(input_name == "zero" || input_name == "one")
			continue;
		str = str + " " + input_name + ";";
	}
	str += " const;";
	str += "}";
	ofs << str << std::endl;

	for(const auto& t1 : get_m_node_level())
	{
		std::string str1 = "{rank = same;";  
		for(const auto& t2 : t1)
		{
			auto it = std::find(const_gates.begin(), const_gates.end(), t2);
			if(it != const_gates.end())//找到了当前层级中的zero one门
				continue;
			str1 = str1 + " " + get_gate(t2).get_name() + ";";
		}
	str1 += "}";
	ofs << str1 << std::endl;
	}

	std::string str2 = "{rank = same;"; 
	for(const auto& output : m_outputs)
	{
		std::string output_name = m_lines[output].name;
		if(output_name.find("\\") != std::string::npos 
		|| output_name.find("[") != std::string::npos 
		|| output_name.find("]") != std::string::npos)
		{
			str2 = str2 + " " + "\"" + output_name + "\"" + ";";
			continue;
		}
		str2 = str2 + " " + output_name + ";";
	}
	str2 += "}";
	ofs << str2 << std::endl;
	ofs << "}" << std::endl;
	ofs.close();

	// 在magic目录下运行magic，dot png文件生成在./dot目录中
	//genarate png and show png 
	if(generate_png)
	{
		// /home/panjiaxiang/pjx_research/magic/dot/netlist_DAG.dot
		// /home/panjiaxiang/pjx_research/magic/dot/netlist_DAG
		// /home/panjiaxiang/pjx_research/magic/dot/netlist_DAG.png
		std::string png_file = m_split(file_name, ".")[0] + ".png"; 

		std::string command = "dot -Tpng " + file_name + " -o " + png_file;
		// m_print( command );
		int result = system( command.c_str() );
		if( result != 0 ) std::cerr << "[Error] Command: " << command << "Failed\n";
		if(show_graph)
		{
			std::string show_command = "eog " + png_file + " 2>/dev/null";
			int result_1 = system( show_command.c_str() );
			if( result_1 != 0 ) std::cerr << "[Error] Command: " << show_command << "Failed\n";
		}
	}
}

void Magic::write_dot_for_extracted_tree( const std::vector<std::vector<gate_idx>> &extract_tree)
{
	std::fstream ofs;
	std::string filename = "../extract_dot/" + m_benchmark_name + "_" + "extracted" +  ".dot";
	ofs.open(filename, std::ios::out);

	ofs << "digraph{" << std::endl;
	ofs << "rankdir = BT" << std::endl;

	int subgraph_size = extract_tree.size();
	for(int i = 0; i < subgraph_size; i++)
	{
		ofs << "subgraph cluster_tree" + std::to_string(i+1) + "{" << std::endl;
		//PI
		for(const auto& input : m_inputs)
		{
			std::string input_name = m_lines[input].name;
			if(input_name.find("\\") != std::string::npos 
			|| input_name.find("[") != std::string::npos 
			|| input_name.find("]") != std::string::npos){
				ofs << "\"" << input_name << "\"" << " [shape=triangle,label=" << "\"" << input_name << "\"" << "];" << std::endl;
				continue;
			}
			ofs << input_name << " [shape=triangle,label=" << input_name << "];" << std::endl;
		}
		//Gates
		for(const auto gate_index : extract_tree[i])
		{
			auto gate = m_gates[gate_index];
			std::string gate_name = gate.get_name();
			std::vector<std::string> children_name;
			for(const auto &input : gate.get_inputs())
			{
				if(m_lines[input].is_input){
					std::string child_name = m_lines[input].name;
					children_name.push_back(child_name);
				}
				else{
					std::string child_name = m_gates[m_lines[input].source].get_name();
					children_name.push_back(child_name);
				}

			}
			//cell usage
			std::string CU = std::to_string(gate.get_cell_usage());
			std::string lable = gate_name + "_" + CU;
			if(gate.get_inv1()){
				ofs << gate_name << " [shape=oval, style = filled, label=" << lable << ", fillcolor = green];" << std::endl;
			}
			else if(gate.get_nor2()){
				ofs << gate_name << " [shape=oval, style = filled, label=" << lable << ", fillcolor = salmon];" << std::endl;
			}
			else{
				assert(false);
			}
			for(const auto& child : children_name)
			{
				if(child.find("\\") != std::string::npos 
				|| child.find("[") != std::string::npos 
				|| child.find("]") != std::string::npos){
					ofs << "\"" << child << "\"" << " -> " << gate_name << std::endl;
					continue;;
				}
				ofs << child << " -> " << gate_name << std::endl;
			}
		}
		//PO
		line_idx output = m_gates[extract_tree[i][0]].get_output();
		std::string output_name = m_lines[output].name;
		if(output_name.find("\\") != std::string::npos 
		|| output_name.find("[") != std::string::npos 
		|| output_name.find("]") != std::string::npos){
			ofs << "\"" << output_name << "\"" << " [shape=invtriangle, label= " << "\"" << output_name << "\"" << "];" << std::endl;
			ofs << m_gates[m_lines[output].source].get_name() << " -> " << "\"" << output_name << "\"" << std::endl;
			continue;
		}
		ofs << output_name << " [shape=invtriangle, label= " << "\"" << output_name << "\"" << "];" << std::endl;
		ofs << m_gates[m_lines[output].source].get_name() << " -> " << output_name << std::endl;
		//Rank
		std::string str = "{rank = same;";
		for(const auto& input : m_inputs)
		{
			std::string input_name = m_lines[input].name;
			if(input_name.find("\\") != std::string::npos 
			|| input_name.find("[") != std::string::npos 
			|| input_name.find("]") != std::string::npos){
				str = str + " " + "\"" + input_name + "\"" + ";";
				continue;
			}
			str = str + " " + input_name + ";";
		}
		str += "}";
		ofs << str << std::endl;
		ofs << "}" << std::endl;
	}

	ofs << "}" << std::endl; 
	ofs.close();
}

void Magic::dfs(const gate_idx &gate, std::vector<gate_idx> &res)
{
	if(!m_gates[gate].is_visited)//当root是别的tree中的节点的时候，如果已经搜索过，就不加入tree中
		res.push_back(gate);
	m_gates[gate].is_visited = true;
	for(const auto &input : m_gates[gate].get_inputs())
	{
		if(m_lines[input].is_input)
			continue;
		gate_idx children_index = m_lines[input].source;
		Gate &children = m_gates[children_index];
		if(children.is_visited)
			continue;
		dfs(children_index, res);
	}
}

void Magic::dfs_2(const gate_idx &gate, std::vector<gate_idx> &res, std::unordered_set<gate_idx> &visited)
{
	res.push_back(gate);
	visited.emplace(gate);
	for(const auto &input : m_gates[gate].get_inputs())
	{
		if(m_lines[input].is_input)
			continue;
		gate_idx children_index = m_lines[input].source;
		if(visited.count(children_index))
			continue;
		dfs_2(children_index, res, visited);
	}
}
 
std::vector<std::vector<gate_idx>> Magic::extract_tree(const std::vector<gate_idx> &roots)
{
	// if(roots.size() != m_outputs.size()){
	// 	throw std::runtime_error("The size of roots is smaller than the size of outputs.");
	// }
	// assert(roots.size() == m_outputs.size());
	if(roots.size() != m_outputs.size())
		std::cout << " *****m_traversal_roots size != output size***** " << std::endl;
	//root在allocate过程中没遍历完，表示mapping失败
	//root遍历完成了，也不代表mapping成功，还需要“进一步判断是否遍历了所有的节点”
	std::vector<std::vector<gate_idx>> extracted_tree;
	for(const auto& root : roots)
	{
		std::vector<gate_idx> result;
		dfs(root, result);
		extracted_tree.push_back(result);
	}
	return extracted_tree;
}

std::vector<std::vector<gate_idx>> Magic::get_trees_for_every_roots(const std::vector<gate_idx> &roots)
{
	std::vector<std::vector<gate_idx>> trees_for_roots;
	// std::unordered_set<gate_idx> visited;
	for(const auto& root : roots)
	{
		std::unordered_set<gate_idx> visited;
		std::vector<gate_idx> result;
		dfs_2(root, result, visited);
		trees_for_roots.push_back(result);
	}
	return trees_for_roots;
}

void Magic::save_generated_micro_operation( const std::string &file_path)
{
	std::string file_name;
	if(!file_path.empty())
	{
		if(!std::filesystem::exists(file_path))
		{
			m_print("file_path not exit, create", file_path);
			std::filesystem::create_directories( file_path );
		}
		if( file_path.back()  == '/' )
		{
			file_name = file_path + m_benchmark_name + "_" + std::to_string(m_row_size) + "_" + m_sort_roots + ".txt";
		}
		else
		{
			file_name = file_path + "/" + m_benchmark_name + "_" + std::to_string(m_row_size) + "_" + m_sort_roots + ".txt";
		}
	}
	else
	{
		std::string home_dir = get_home_dir();
		file_name = home_dir + "/" + m_benchmark_name + "_" + std::to_string(m_row_size) + "_" + m_sort_roots + ".txt";
	}
	std::ofstream ofs;
	ofs.open(file_name, std::ios::out);
	
	ofs << "********** MAPPING OF " << m_benchmark_name << " WITH ROW SIZE = " << m_row_size << "**********" << std::endl;
	ofs << "Benchmark: " << m_benchmark_name << std::endl;
	ofs << "Row size: " << m_row_size << std::endl;
	ofs << "Number of Gates: " << m_gates.size() << std::endl;

	std::string input_str = "Inputs: {";
	for(int i = 0; i < m_inputs.size(); i++)
	{
		std::string str = m_lines[get_inputs()[i]].name + "(" + std::to_string(i) + "),";//map of input = index of input
		if( m_lines[get_inputs()[i]].name == "one" || m_lines[get_inputs()[i]].name == "zero" )
			continue;
		input_str += str;
	}
	input_str += "}";
	ofs << input_str << std::endl;

	std::string output_str = "Outputs: {";
	for(const auto &output_line : m_outputs)
	{
		std::string str = m_lines[output_line].name + "(" + std::to_string(m_gates[m_lines[output_line].source].get_map()) + "),";
		output_str += str;
	}
	output_str += "}";
	ofs << output_str << std::endl;

	//解析的时候将zero one解析为了PI， 打印信息的时候需要去除
	ofs << "Number of PIs: " << PI_size_without_zero_one << std::endl;
	//ofs << "Number of PIs: " << m_inputs.size() << std::endl;
	ofs << "Number of POs: " << m_outputs.size() << std::endl;
	ofs << "Total cycles: " << m_time << std::endl;
	ofs << "Reuse cycles: " << m_reuse_cycles << std::endl;
	double percentage = static_cast<double>(m_reuse_cycles) / m_time * 100;
	ofs<< "Reuse percentage: " << std::setprecision(2) << percentage << "%" << std::endl;
	ofs << "Execution sequence:  " << std::endl;

	std::string str = "Cycle0: \"Initialization(Ron){ ";
	for(int i = PI_size_without_zero_one; i < m_row_size; i++)
	{
		std::string s = "INIT_CYCLE( " + std::to_string(i) + " ),";
		str += s;
	}
	str += " }";
	ofs << str << std::endl;

	for(const auto& [time, value] : m_micro_operation)
	{
		std::string gate_type{};
		std::vector<std::string> input_line_name{};//store the name of gate input_lines
		std::vector<int> cell_locations{};//store the cell_idx of gates input
		if (std::holds_alternative<gate_idx>(value))
        {
            auto gate_index = std::get<gate_idx>(value);
			std::string gate_type{};
			std::vector<std::string> input_line_name{};//store the name of gate input_lines
			std::vector<int> cell_locations{};//store the cell_idx of gates input
			if(m_gates[gate_index].get_inv1() || m_gates[gate_index].get_buf()){
				if(m_gates[gate_index].get_inv1())
					gate_type = "inv1";
				else gate_type = "buf";
				std::vector<line_idx> input_line_index = m_gates[gate_index].get_inputs();
				for(const auto &input : input_line_index)
				{
					input_line_name.push_back(m_lines[input].name);
					if(m_lines[input].is_input)
					{
						cell_locations.push_back(input);
					}
					else if(m_lines[input].is_output)
					{
						// cell_locations.push_back(input);
						gate_idx gate_index = m_lines[input].source;
						cell_locations.push_back(m_gates[gate_index].get_map());
					}
					else//is_wire
					{
						gate_idx gate_index = m_lines[input].source;
						cell_locations.push_back(m_gates[gate_index].get_map());
					}
				}
			}
			else if(m_gates[gate_index].get_nor2() || m_gates[gate_index].get_nor3() ||
			m_gates[gate_index].get_nor4() || m_gates[gate_index].get_nor5()){
				if(m_gates[gate_index].get_nor2())
					gate_type = "nor2";
				else if(m_gates[gate_index].get_nor3())
					gate_type = "nor3";
				else if(m_gates[gate_index].get_nor4())
					gate_type = "nor4";
				else if(m_gates[gate_index].get_nor5())
					gate_type = "nor5";
				std::vector<line_idx> input_line_index = m_gates[gate_index].get_inputs();
				for(const auto &input : input_line_index)
				{
					input_line_name.push_back(m_lines[input].name);
					if(m_lines[input].is_input)
					{
						cell_locations.push_back(input);
					}
					else if(m_lines[input].is_output)
					{
						// cell_locations.push_back(input);
						gate_idx gate_index = m_lines[input].source;
						cell_locations.push_back(m_gates[gate_index].get_map());
					}
					else//is_wire
					{
						gate_idx gate_index = m_lines[input].source;
						cell_locations.push_back(m_gates[gate_index].get_map());
					}
				}
			}
			else if(m_gates[gate_index].get_zero() || m_gates[gate_index].get_one())
			{
				if(m_gates[gate_index].get_zero())
					gate_type = "zero";
				else gate_type = "one";
			}
			else{
				gate_type = "no_type";
				//assert(gate_type != "no_type");
				std::cout << "no_type!" << std::endl;
			}
			std::string cycle = std::to_string(time);
			auto output_line = m_gates[gate_index].get_output();
			std::string output_line_name = m_lines[output_line].name;
			if(gate_type == "inv1")
			{
				ofs << "Cycle" << cycle << ": " << output_line_name << "(" << m_gates[gate_index].get_map() << ")" << "=" << gate_type << "{" << input_line_name[0] << "(" << cell_locations[0]  << ")" << "}" << std::endl;
			}
			else if(gate_type == "nor2")
			{
				ofs << "Cycle" << cycle << ": " << output_line_name << "(" << m_gates[gate_index].get_map()  << ")" << "=" << gate_type << "{" << input_line_name[0] << "(" << cell_locations[0]  << ")" << "," <<  input_line_name[1] << "(" << cell_locations[1]  << ")"  << "}" << std::endl;
			}
			else if(gate_type == "nor3")
			{
				ofs << "Cycle" << cycle << ": " << output_line_name << "(" << m_gates[gate_index].get_map()  << ")" << "=" << gate_type << "{" << input_line_name[0] << "(" << cell_locations[0]  << ")" << "," <<  input_line_name[1] << "(" << cell_locations[1]  << ")" << "," <<  input_line_name[2] << "(" << cell_locations[2]  << ")"  << "}" << std::endl;
			}
			else if(gate_type == "nor4")
			{
				ofs << "Cycle" << cycle << ": " << output_line_name << "(" << m_gates[gate_index].get_map()  << ")" << "=" << gate_type << "{" << input_line_name[0] << "(" << cell_locations[0]  << ")" << "," <<  input_line_name[1] << "(" << cell_locations[1]  << ")" << "," <<  input_line_name[2] << "(" << cell_locations[2]  << ")" << "," <<  input_line_name[3] << "(" << cell_locations[3]  << ")"  << "}" << std::endl;
			}
			else if(gate_type == "nor5")
			{
				ofs << "Cycle" << cycle << ": " << output_line_name << "(" << m_gates[gate_index].get_map()  << ")" << "=" << gate_type << "{" << input_line_name[0] << "(" << cell_locations[0]  << ")" << "," <<  input_line_name[1] << "(" << cell_locations[1]  << ")" << "," <<  input_line_name[2] << "(" << cell_locations[2]  << ")" << "," <<  input_line_name[3] << "(" << cell_locations[3]  << ")" << "," <<  input_line_name[4] << "(" << cell_locations[4]  << ")"  << "}" << std::endl;
			}
			else if(gate_type == "buf")
			{
				ofs << "Cycle" << cycle << ": " << output_line_name << "(" << m_gates[gate_index].get_map() << ")" << "=" << gate_type << "{" << input_line_name[0] << "(" << cell_locations[0]  << ")" << "}" << std::endl;
			}
			else if(gate_type == "zero")
			{
				auto output_line = m_gates[gate_index].get_output();
				std::string output_name = m_lines[output_line].name;
				ofs << "assign constant input zero to PO: " << output_name << std::endl; 
			}
			else if(gate_type == "one")
			{
				auto output_line = m_gates[gate_index].get_output();
				std::string output_name = m_lines[output_line].name;
				ofs << "assign constant input one to PO: " << output_name << std::endl; 
			}
			else
			{
				ofs << "error output! " << std::endl;
			}

        }
		else if(std::holds_alternative<std::vector<gate_idx>>(value))//INITIALIZE
		{
			std::string init_str = "Cycle";
			init_str = init_str + std::to_string(time) + ":Initialization(Ron){";
			for (const auto& gate : std::get<std::vector<gate_idx>>(value))
            {
                auto output_line = m_gates[gate].get_output();
				m_lines[output_line].name;
				init_str = init_str + m_lines[ m_gates[gate].get_output()].name + "(" + std::to_string(m_gates[gate].get_map()) + "),";
            }
			init_str += "}";
			ofs << init_str << std::endl;
		}
	}
	ofs.close();
}

void Magic::save_generated_micro_operation_SA( const std::string &file_path )
{
	std::string file_name;
	if(!file_path.empty())
	{
		if(!std::filesystem::exists(file_path))
		{
			m_print("file_path not exit, create", file_path);
			std::filesystem::create_directories( file_path );
		}
		if( file_path.back()  == '/' )
		{
			file_name = file_path + m_benchmark_name + "_" + std::to_string(costRootsPair.first + PI_size_without_zero_one) + "_SA" +  + ".txt";
		}
		else
		{
			file_name = file_path + "/" + m_benchmark_name + "_" + std::to_string(costRootsPair.first + PI_size_without_zero_one) + "_SA" +  + ".txt";
		}
	}
	else
	{
		std::string home_dir = get_home_dir();
		file_name = home_dir + "/" + m_benchmark_name + "_" + std::to_string(costRootsPair.first + PI_size_without_zero_one) + "_SA" +  + ".txt";
	}
	std::ofstream ofs;
	ofs.open(file_name, std::ios::out);
	
	ofs << "********** MAPPING OF " << m_benchmark_name << "WITH ROW SIZE = " << costRootsPair.first + PI_size_without_zero_one << "**********" << std::endl;
	ofs << "Benchmark: " << m_benchmark_name << std::endl;
	ofs << "Row size: " << costRootsPair.first + PI_size_without_zero_one << std::endl;
	ofs << "Number of Gates: " << m_gates.size() << std::endl;

	std::string input_str = "Inputs: {";
	for(int i = 0; i < m_inputs.size(); i++)
	{
		// std::string str = m_lines[i].name + "(" + std::to_string(i) + "),";//map of input = index of input
		//bug fixed! 此前是访问line的name，应该修改为访问input的index对应的line的name
		std::string str = m_lines[get_inputs()[i]].name + "(" + std::to_string(i) + "),";//map of input = index of input
		if( m_lines[get_inputs()[i]].name == "one" || m_lines[get_inputs()[i]].name == "zero" )
			continue;
		input_str += str;
	}
	input_str += "}";
	ofs << input_str << std::endl;

	std::string output_str = "Outputs: {";
	for(const auto &output_line : m_outputs)
	{
		std::string str = m_lines[output_line].name + "(" + std::to_string(m_gates[m_lines[output_line].source].get_map_SA()) + "),";
		output_str += str;
	}
	output_str += "}";
	ofs << output_str << std::endl;
	
	ofs << "Number of PIs: " << PI_size_without_zero_one << std::endl;
	//ofs << "Number of PIs: " << m_inputs.size() << std::endl;
	ofs << "Number of POs: " << m_outputs.size() << std::endl;
	ofs << "Total cycles: " << m_time_SA << std::endl;
	ofs << "Reuse cycles: " << m_reuse_cycles_SA << std::endl;
	double percentage = static_cast<double>(m_reuse_cycles_SA) / m_time_SA * 100;
	ofs<< "Reuse percentage: " << std::setprecision(2) << percentage << "%" << std::endl;
	ofs << "Execution sequence:  " << std::endl;

	std::string str = "Cycle0: \"Initialization(Ron){ ";
	for(int i = PI_size_without_zero_one; i < PI_size_without_zero_one + costRootsPair.first; i++)//需要修改
	{
		std::string s = "INIT_CYCLE( " + std::to_string(i) + " ),";
		str += s;
	}
	str += " }";
	ofs << str << std::endl;

	for(const auto& [time, value] : m_micro_operation_SA)
	{
		std::string gate_type{};
		std::vector<std::string> input_line_name{};//store the name of gate input_lines
		std::vector<int> cell_locations{};//store the cell_idx of gates input
		if (std::holds_alternative<gate_idx>(value))
        {
            auto gate_index = std::get<gate_idx>(value);
			std::string gate_type{};
			std::vector<std::string> input_line_name{};//store the name of gate input_lines
			std::vector<int> cell_locations{};//store the cell_idx of gates input
			if(m_gates[gate_index].get_inv1() || m_gates[gate_index].get_buf()){
				if(m_gates[gate_index].get_inv1())
					gate_type = "inv1";
				else gate_type = "buf";
				std::vector<line_idx> input_line_index = m_gates[gate_index].get_inputs();
				for(const auto &input : input_line_index)
				{
					input_line_name.push_back(m_lines[input].name);
					if(m_lines[input].is_input)
					{
						cell_locations.push_back(input);
					}
					else if(m_lines[input].is_output)
					{
						// cell_locations.push_back(input);
						gate_idx gate_index = m_lines[input].source;
						cell_locations.push_back(m_gates[gate_index].get_map_SA());
					}
					else//is_wire
					{
						gate_idx gate_index = m_lines[input].source;
						cell_locations.push_back(m_gates[gate_index].get_map_SA());
					}
				}
			}
			else if(m_gates[gate_index].get_nor2() || m_gates[gate_index].get_nor3() ||
			m_gates[gate_index].get_nor4() || m_gates[gate_index].get_nor5()){
				if(m_gates[gate_index].get_nor2())
					gate_type = "nor2";
				else if(m_gates[gate_index].get_nor3())
					gate_type = "nor3";
				else if(m_gates[gate_index].get_nor4())
					gate_type = "nor4";
				else if(m_gates[gate_index].get_nor5())
					gate_type = "nor5";
				std::vector<line_idx> input_line_index = m_gates[gate_index].get_inputs();
				for(const auto &input : input_line_index)
				{
					input_line_name.push_back(m_lines[input].name);
					if(m_lines[input].is_input)
					{
						cell_locations.push_back(input);
					}
					else if(m_lines[input].is_output)
					{
						// cell_locations.push_back(input);
						gate_idx gate_index = m_lines[input].source;
						cell_locations.push_back(m_gates[gate_index].get_map_SA());
					}
					else//is_wire
					{
						gate_idx gate_index = m_lines[input].source;
						cell_locations.push_back(m_gates[gate_index].get_map_SA());
					}
				}
			}
			else if(m_gates[gate_index].get_zero() || m_gates[gate_index].get_one())
			{
				if(m_gates[gate_index].get_zero())
					gate_type = "zero";
				else gate_type = "one";
			}
			else{
				gate_type = "no_type";
				//assert(gate_type != "no_type");
				std::cout << "no_type!" << std::endl;
			}
			std::string cycle = std::to_string(time);
			auto output_line = m_gates[gate_index].get_output();
			std::string output_line_name = m_lines[output_line].name;
			if(gate_type == "inv1")
			{
				ofs << "Cycle" << cycle << ": " << output_line_name << "(" << m_gates[gate_index].get_map_SA() << ")" << "=" << gate_type << "{" << input_line_name[0] << "(" << cell_locations[0]  << ")" << "}" << std::endl;
			}
			else if(gate_type == "nor2")
			{
				ofs << "Cycle" << cycle << ": " << output_line_name << "(" << m_gates[gate_index].get_map_SA()  << ")" << "=" << gate_type << "{" << input_line_name[0] << "(" << cell_locations[0]  << ")" << "," <<  input_line_name[1] << "(" << cell_locations[1]  << ")"  << "}" << std::endl;
			}
			else if(gate_type == "nor3")
			{
				ofs << "Cycle" << cycle << ": " << output_line_name << "(" << m_gates[gate_index].get_map_SA()  << ")" << "=" << gate_type << "{" << input_line_name[0] << "(" << cell_locations[0]  << ")" << "," <<  input_line_name[1] << "(" << cell_locations[1]  << ")" << "," <<  input_line_name[2] << "(" << cell_locations[2]  << ")"  << "}" << std::endl;
			}
			else if(gate_type == "nor4")
			{
				ofs << "Cycle" << cycle << ": " << output_line_name << "(" << m_gates[gate_index].get_map_SA()  << ")" << "=" << gate_type << "{" << input_line_name[0] << "(" << cell_locations[0]  << ")" << "," <<  input_line_name[1] << "(" << cell_locations[1]  << ")" << "," <<  input_line_name[2] << "(" << cell_locations[2]  << ")" << "," <<  input_line_name[3] << "(" << cell_locations[3]  << ")"  << "}" << std::endl;
			}
			else if(gate_type == "nor5")
			{
				ofs << "Cycle" << cycle << ": " << output_line_name << "(" << m_gates[gate_index].get_map_SA()  << ")" << "=" << gate_type << "{" << input_line_name[0] << "(" << cell_locations[0]  << ")" << "," <<  input_line_name[1] << "(" << cell_locations[1]  << ")" << "," <<  input_line_name[2] << "(" << cell_locations[2]  << ")" << "," <<  input_line_name[3] << "(" << cell_locations[3]  << ")" << "," <<  input_line_name[4] << "(" << cell_locations[4]  << ")"  << "}" << std::endl;
			}
			else if(gate_type == "buf")
			{
				ofs << "Cycle" << cycle << ": " << output_line_name << "(" << m_gates[gate_index].get_map_SA() << ")" << "=" << gate_type << "{" << input_line_name[0] << "(" << cell_locations[0]  << ")" << "}" << std::endl;
			}
			else if(gate_type == "zero")
			{
				auto output_line = m_gates[gate_index].get_output();
				std::string output_name = m_lines[output_line].name;
				ofs << "assign constant input zero to PO: " << output_name << std::endl; 
			}
			else if(gate_type == "one")
			{
				auto output_line = m_gates[gate_index].get_output();
				std::string output_name = m_lines[output_line].name;
				ofs << "assign constant input one to PO: " << output_name << std::endl; 
			}
			else
			{
				ofs << "error output! " << std::endl;
			}

        }
		else if(std::holds_alternative<std::vector<gate_idx>>(value))//INITIALIZE
		{
			std::string init_str = "Cycle";
			init_str = init_str + std::to_string(time) + ":Initialization(Ron){";
			for (const auto& gate : std::get<std::vector<gate_idx>>(value))
            {
                auto output_line = m_gates[gate].get_output();
				m_lines[output_line].name;
				init_str = init_str + m_lines[ m_gates[gate].get_output()].name + "(" + std::to_string(m_gates[gate].get_map_SA()) + "),";
            }
			init_str += "}";
			ofs << init_str << std::endl;
		}
	}
	ofs.close();
}

void Magic::save_generated_micro_operation_SA_veriSIMPLER( const std::string &file_path )
{
	std::string file_name;
	if(!file_path.empty())
	{
		if(!std::filesystem::exists(file_path))
		{
			m_print("file_path not exit, create", file_path);
			std::filesystem::create_directories( file_path );
		}
		if( file_path.back()  == '/' )
		{
			file_name = file_path + m_benchmark_name + "_" + std::to_string(costRootsPair.first + PI_size_without_zero_one) + "_SA_veriSIMPLER" +  + ".txt";
		}
		else
		{
			file_name = file_path + "/" + m_benchmark_name + "_" + std::to_string(costRootsPair.first + PI_size_without_zero_one) + "_SA_veriSIMPLER" +  + ".txt";
		}
	}
	else
	{
		std::string home_dir = get_home_dir();
		file_name = home_dir + "/" + m_benchmark_name + "_" + std::to_string(costRootsPair.first + PI_size_without_zero_one) + "_SA_veriSIMPLER" +  + ".txt";
	}
	std::ofstream ofs;
	ofs.open(file_name, std::ios::out);
	
	ofs << "********** MAPPING OF " << m_benchmark_name << "WITH ROW SIZE = " << costRootsPair.first + PI_size_without_zero_one << "**********" << std::endl;
	ofs << "Benchmark: " << m_benchmark_name << std::endl;
	ofs << "Row size: " << costRootsPair.first + PI_size_without_zero_one << std::endl;
	ofs << "Number of Gates: " << m_gates.size() << std::endl;

	std::string input_str = "Inputs: ";
	for(int i = 0; i < m_inputs.size(); i++)
	{
		// std::string str = m_lines[i].name + "(" + std::to_string(i) + "),";//map of input = index of input
		//bug fixed! 此前是访问line的name，应该修改为访问input的index对应的line的name
		std::string str = m_lines[get_inputs()[i]].name + "(M" + std::to_string(i) + ")";//map of input = index of input
		if( m_lines[get_inputs()[i]].name == "one" || m_lines[get_inputs()[i]].name == "zero" )
			continue;
		if( i < PI_size_without_zero_one - 1 )
		{
			str += ",";
		}
		input_str += str;
	}
	ofs << input_str << std::endl;

	std::string output_str = "Outputs: ";
	int flag = 0;
	for(const auto &output_line : m_outputs)
	{
		std::string str = m_lines[output_line].name + "(M" + std::to_string(m_gates[m_lines[output_line].source].get_map_SA()) + ")";
		if( flag < m_outputs.size() - 1 )
		{
			str += ",";
			flag += 1;
		}
		output_str += str;
	}
	ofs << output_str << std::endl;
	
	ofs << "Number of PIs: " << PI_size_without_zero_one << std::endl;
	//ofs << "Number of PIs: " << m_inputs.size() << std::endl;
	ofs << "Number of POs: " << m_outputs.size() << std::endl;
	ofs << "Total cycles: " << m_time_SA << std::endl;
	ofs << "Reuse cycles: " << m_reuse_cycles_SA << std::endl;
	double percentage = static_cast<double>(m_reuse_cycles_SA) / m_time_SA * 100;
	ofs<< "Reuse percentage: " << std::setprecision(2) << percentage << "%" << std::endl;
	ofs << "Execution sequence:" << std::endl;

	std::string str = "T0: INIT ";
	for(int i = PI_size_without_zero_one; i < PI_size_without_zero_one + costRootsPair.first; i++)//需要修改
	{
		std::string s = "M" + std::to_string(i);
		if( i < PI_size_without_zero_one + costRootsPair.first - 1 )
		{
			s += ",";
		}
		str += s;
	}
	ofs << str << std::endl;

	for(const auto& [time, value] : m_micro_operation_SA)
	{
		std::string gate_type{};
		std::vector<std::string> input_line_name{};//store the name of gate input_lines
		std::vector<int> cell_locations{};//store the cell_idx of gates input
		if (std::holds_alternative<gate_idx>(value))
        {
            auto gate_index = std::get<gate_idx>(value);
			std::string gate_type{};
			std::vector<std::string> input_line_name{};//store the name of gate input_lines
			std::vector<int> cell_locations{};//store the cell_idx of gates input
			if(m_gates[gate_index].get_inv1() || m_gates[gate_index].get_buf()){
				if(m_gates[gate_index].get_inv1())
					gate_type = "inv1";
				else gate_type = "buf";
				std::vector<line_idx> input_line_index = m_gates[gate_index].get_inputs();
				for(const auto &input : input_line_index)
				{
					input_line_name.push_back(m_lines[input].name);
					if(m_lines[input].is_input)
					{
						cell_locations.push_back(input);
					}
					else if(m_lines[input].is_output)
					{
						// cell_locations.push_back(input);
						gate_idx gate_index = m_lines[input].source;
						cell_locations.push_back(m_gates[gate_index].get_map_SA());
					}
					else//is_wire
					{
						gate_idx gate_index = m_lines[input].source;
						cell_locations.push_back(m_gates[gate_index].get_map_SA());
					}
				}
			}
			else if(m_gates[gate_index].get_nor2() || m_gates[gate_index].get_nor3() ||
			m_gates[gate_index].get_nor4() || m_gates[gate_index].get_nor5()){
				if(m_gates[gate_index].get_nor2())
					gate_type = "nor2";
				else if(m_gates[gate_index].get_nor3())
					gate_type = "nor3";
				else if(m_gates[gate_index].get_nor4())
					gate_type = "nor4";
				else if(m_gates[gate_index].get_nor5())
					gate_type = "nor5";
				std::vector<line_idx> input_line_index = m_gates[gate_index].get_inputs();
				for(const auto &input : input_line_index)
				{
					input_line_name.push_back(m_lines[input].name);
					if(m_lines[input].is_input)
					{
						cell_locations.push_back(input);
					}
					else if(m_lines[input].is_output)
					{
						// cell_locations.push_back(input);
						gate_idx gate_index = m_lines[input].source;
						cell_locations.push_back(m_gates[gate_index].get_map_SA());
					}
					else//is_wire
					{
						gate_idx gate_index = m_lines[input].source;
						cell_locations.push_back(m_gates[gate_index].get_map_SA());
					}
				}
			}
			else if(m_gates[gate_index].get_zero() || m_gates[gate_index].get_one())
			{
				if(m_gates[gate_index].get_zero())
					gate_type = "zero";
				else gate_type = "one";
			}
			else{
				gate_type = "no_type";
				//assert(gate_type != "no_type");
				std::cout << "no_type!" << std::endl;
			}
			std::string cycle = std::to_string(time);
			auto output_line = m_gates[gate_index].get_output();
			std::string output_line_name = m_lines[output_line].name;
			if(gate_type == "inv1")
			{
				ofs << "T" << cycle << ": " << "M" << m_gates[gate_index].get_map_SA() << " = " << gate_type << " {" << "M" << cell_locations[0] << "}\n";
			}
			else if(gate_type == "nor2")
			{
				ofs << "T" << cycle << ": " << "M" << m_gates[gate_index].get_map_SA() << " = " << gate_type << " {" << "M" << cell_locations[0] << "," << "M" << cell_locations[1] << "}\n";
			}
			else if(gate_type == "nor3")
			{
				ofs << "T" << cycle << ": " << output_line_name << "(" << m_gates[gate_index].get_map_SA()  << ")" << "=" << gate_type << "{" << input_line_name[0] << "(" << cell_locations[0]  << ")" << "," <<  input_line_name[1] << "(" << cell_locations[1]  << ")" << "," <<  input_line_name[2] << "(" << cell_locations[2]  << ")"  << "}" << std::endl;
			}
			else if(gate_type == "nor4")
			{
				ofs << "T" << cycle << ": " << output_line_name << "(" << m_gates[gate_index].get_map_SA()  << ")" << "=" << gate_type << "{" << input_line_name[0] << "(" << cell_locations[0]  << ")" << "," <<  input_line_name[1] << "(" << cell_locations[1]  << ")" << "," <<  input_line_name[2] << "(" << cell_locations[2]  << ")" << "," <<  input_line_name[3] << "(" << cell_locations[3]  << ")"  << "}" << std::endl;
			}
			else if(gate_type == "nor5")
			{
				ofs << "T" << cycle << ": " << output_line_name << "(" << m_gates[gate_index].get_map_SA()  << ")" << "=" << gate_type << "{" << input_line_name[0] << "(" << cell_locations[0]  << ")" << "," <<  input_line_name[1] << "(" << cell_locations[1]  << ")" << "," <<  input_line_name[2] << "(" << cell_locations[2]  << ")" << "," <<  input_line_name[3] << "(" << cell_locations[3]  << ")" << "," <<  input_line_name[4] << "(" << cell_locations[4]  << ")"  << "}" << std::endl;
			}
			else if(gate_type == "buf")
			{
				ofs << "T" << cycle << ": " << "M" << m_gates[gate_index].get_map_SA() << " = " << gate_type << " {" << "M" << cell_locations[0]  << "}\n";
			}
			else if(gate_type == "zero")
			{
				auto output_line = m_gates[gate_index].get_output();
				std::string output_name = m_lines[output_line].name;
				ofs << "assign constant input zero to PO: " << output_name << std::endl; 
			}
			else if(gate_type == "one")
			{
				auto output_line = m_gates[gate_index].get_output();
				std::string output_name = m_lines[output_line].name;
				ofs << "assign constant input one to PO: " << output_name << std::endl; 
			}
			else
			{
				ofs << "error output! " << std::endl;
			}

        }
		// else if(std::holds_alternative<std::vector<gate_idx>>(value))//INITIALIZE
		// {                                   
		// 	std::string init_str = "T";
		// 	init_str = init_str + std::to_string(time) + ": INIT ";
		// 	for (const auto& gate : std::get<std::vector<gate_idx>>(value))
        //     {
        //         auto output_line = m_gates[gate].get_output();
		// 		m_lines[output_line].name;
		// 		init_str = init_str + "M" + std::to_string(m_gates[gate].get_map_SA()) + ",";
        //     }
		// 	ofs << init_str << std::endl;
		// }
		else if (std::holds_alternative<std::vector<gate_idx>>(value)) // INITIALIZE
		{
			std::string init_str = "T";
			init_str = init_str + std::to_string(time) + ": INIT ";
			
			const auto& gates = std::get<std::vector<gate_idx>>(value);
			for (size_t i = 0; i < gates.size(); ++i)
			{
				auto gate = gates[i];
				auto output_line = m_gates[gate].get_output();
				m_lines[output_line].name; // This seems unused, but keeping as-is.

				init_str += "M" + std::to_string(m_gates[gate].get_map_SA());

				// Only add a comma if it's not the last element
				if (i < gates.size() - 1)
				{
					init_str += ",";
				}
			}

			ofs << init_str << std::endl;
		}

	}
	ofs.close();
}